 In this video, I'm going to discuss low pass filtering and ERP basically removing the high frequency activity in an event related potential and focusing the Time series, the waveform shaped more on the lower frequencies. Now averaging over trials itself is already a low pass filter because high frequency activity is less likely to be preserved when averaging over multiple trials compared to the low frequency activity. However, we are here going to even further low pass filter by explicitly filtering, using and FBAR filter. So let me give you the big picture overview of the script and then I'll go back and show you each individual line. So here we load in the data and then just for convenience, I'm already going to extract only the data from this channel from Channel seven. Here is the low frequency cutoff. So we're going to filter below 20 hertz here. I'm going to create and inspect the filter, Colonel. That's always really important whenever you're filtering, it's really important to look at the filter, Colonel, to inspect the filter colonel in the time and in the frequency domains before you actually apply it to your signal. And then I'm going to show you three different options for filtering the ERP. First, we compute the ERP and then apply the filter to the trial average. Here is option two. I'm going to filter each trial separately and then add them together to create an event related potential. And here what I'm going to do is concatenate so I'm going to take the time by trials matrix and reshape it into one really long trial. When I call a super trial and then I'll filter that super long trial and then reshape it back into a time by trials matrix and then compute the event related potential and then we'll plot all three of them on top of each other to see how they compare. Now, if you are going through this code on your own, I encourage you first to think about whether options one, two and three will differ from each other, whether you're going to get different results. Basically, if you filter the ERP or filter the single trials and then create an ERP. So try and use a bit of intuition and come up with a guess, with an hypothesis, and then we can find out whether you were right or wrong. So basically, will these differ? And if they differ, then how will they differ? All right, let's get started here, reloading the data. And just to have a quick inspection of this data, it's 5500 by two hundred. And that makes sense because that's time by trials. Now, normally, at this point, I would encourage you to make an image of this and just have a quick look at the quality of the data. Actually, it should be plotted this way. That's a little more sensible. But I've already shown you exactly as image in the previous video, so we don't need to worry about that too much here. I'm going to create and inspect the filter kernel. I'm using the feature one function now, many different filter construction algorithms. I talk more about this in my course on signal processing. So I don't want to get into too much detail about this here except to say that to use these functions FIA one FIA, unless there's a whole family of these things, you input the filter order, which is basically the length of the filter kernel and then you specify the frequencies. In this case, we are generating a low pass filter, so we only need to input one frequency, which is the upper cutoff of the low pass filter. And that's specified in units of Nykvist, I should say, as a fraction of knackwurst. And the filter order is a little bit hard to calculate definitively, which is to say that the filter order is a parameter of the filter and you can specify it in different ways. In general, a good way to specify the filter order is as some integer multiple of the number of time points in one cycle at that frequency. So the number of time points in one cycle of 20 hertz is whatever this number happens to be. So around twenty six time points and then I multiply that by 18. So that's kind of a increasing factor. And then of course this has to be rounded because it only makes sense to have this be some integer, because this is going to correspond to the length of this kernel. And here what I'm going to do is plot the kernel and the time domain so we can look at it. And then here I will plot the power spectrum of the filter kernel. So let's run this wholesale. Here you see what the filter kind of looks like, and this is the power spectrum, which for a filter you can think about as a gain function in the frequency domain. So these are the frequencies that will pass through the filter at a gain of one. So these frequencies won't be touched. These frequencies here will pass through the filter, but be sharply attenuated and then these won't pass through the filter at all. In fact, this is not really zero. We can try setting the WI scale to be logarithmic and you'll see that the gain is actually really, really small. It's not zero. So technically there's a tiny, tiny bit of energy at these higher frequencies that leak into the signal. But that's a very, very small gain. OK, so what I would like to do now, just to show you a little bit about the importance of this filter order, is decrease this filter order. Let's make it, let's say eight to nine, rerun this cell. Now, this change that's actually got shorter. Let me go back and show you this. So let's see. So here's 18 and you can see that the filter colonel spends a little over 600 milliseconds. And now when I said it to eight, a factor of eight. So then the filter order is around 200. Now the filter kernel is much shorter. It's like two hundred and seventy milliseconds. And look at what happens here in the frequency domain. So now this frequency domain gain function is much worse. We're already starting to attenuate frequencies above around, you know, whatever. This is so around like 14 or 15 hertz. So this is not as good. Now you could say, well, let's just make this really huge and then we got a better filter, but longer filters are not necessarily better. Now, this filter is nearly three seconds long, which in fact is longer than the Time series itself. And so turns out Matlab is going to give us some difficulties with that. So 18 is a pretty good range. All right. Now, what I'm going to do is filter the ERP. So I compute the ERP as the average, the mean of the data over the second dimension, which is trials. And I'm using this function filled filter, which is located inside the signal processing toolbox. And the main three inputs that you need are the filter kernel, which are sometimes called the B coefficients, the coefficients which for an F air filter are always set to one. So any time you're using an FIA filter, the second input will always be one. And then the thing that you want to filter, which is ERP one. So I'm going to run this code. We don't get any errors, we don't get any warnings. And it's probably a good idea. Just have a quick look at this thing. So I'm going to plot ERP one and mainly I just want to make sure that it looks plausible. It looks real. And this it does. In fact, I think I'll plot the on average data first and then type hold on and I'll run this and then I will plot this again with a red line. So it's pretty interesting to see the difference between the filtered and unfiltered version of the ERP. Mostly if you look here in this time window now, this is just time indices. This is not time and milliseconds. So around here and around here, you might say that the filtered IRP looks better because maybe you assume that a lot of these fluctuations in the blue line are noise. But here you get here and you see that there are these really large amplitude, really reliable fluctuations. These are phase locked gamma oscillations. So high frequency oscillations in blue and those are totally obliterated by this low pass filtered version. Now, whether this is a good thing or a bad thing, as a matter of debate, in fact, what we are doing is separating multiple sources within this ERP. So there's a low frequency source and a high frequency source. And by filtering, we are attenuating are actually, in this case, eliminating the higher frequency source. OK, so we can be confident that this code is correct, because the result looks good. Now I want to try filtering these single trials. So what I'm going to do here is initialize ERP, too. So that's going to be just one by time. So a vector of time. And now look what I'm doing. I'm looping over all the trials and I'm applying the almost exactly the same filter filter function as here. So it's the same filter kernel. But now instead of filtering the ERP, I'm only filtering the data from one trial and the results. This is one trial that gets filtered, low pass filtered. It gets added back onto this variable ERP two. And then here after we go through all the loops or started looping over all the trials, then I divide by the number of trials. And essentially this is just taking the average over all the trials. So here we get an error, so that means we need to investigate. So it says error using plus matrix dimensions must agree so that errors obviously coming from this line. And it means that somehow this line is not working, which means that this has a different dimensionality, a different size compared to this. So let's try looking at the size of this things. I'm going to say size of this, and this is one hundred twenty seven by one. And now we can see the size of IRP two, and that is not the same size. So this is a column vector and this is a row vector. So it's not possible to add one to the other, so there's two ways that you can fix this. One is you can initialize it to be a column vector or you can transpose this to be a row vector. OK, so now we get a result. And I'm not going to plot this yet because I'm building suspense for when we get to see all of these plotted on top of each other. Here is the third option. Now, this might seem like a weird thing to do at first, but what I'm doing is reshaping the data from a matrix, a time by trials matrix into one really long trial. So this is a single vector that is three hundred thousand times points long. And let's see what this looks like. So plot super trial. And this might look like a just total noise. It's hard to interpret. So let's zoom in. Now, what's going on here is that the first fifteen hundred trials so far from here are sorry, first fifteen hundred time points from here up to here. This is trial one and then trial two immediately starts right here and goes up to around three thousand. So this is trial one and this is trial two and so on for all two hundred trials. Now, I'm going to apply the filter to this really long trial. And hold on and then plot super trial again in red. So now again, you see this is trial one going up to around 50, 100 or so, and then this is trial two. And now what I'm going to do is reshape this back to the original size. So this is a vector of three hundred thousand time points. Now it gets reshaped back to hundred by two hundred, which was the original size, and then I average over trials. OK, and now for the comparison. Now, this code might look a little weird, maybe you're not familiar with this evil function, basically there's three ways to do this. One, I could write out the plot function multiple times or three times, or I can try putting it in a loop. The problem with putting it in the loop is that the variables themselves, the names of the variables, are changing for the different variables. So it's ERP one, ERP two, ERP three now that on its own is not Lupul. So what I'm doing instead is creating a string that will include that number. So you can see this as plot time back by ERP. And now the string ends and we say, no string I. And this is our looping index that goes one through three. And then we have the rest of the plotting line. So if you just look at the contents of this square bracket in here. You would see this is a plot function that we want to run IRP one, and this is just finding a unique color and marker shape that's here for each of the three lines. And then I take that string and put it into the evil function, which will evaluate that string. Now, you might be thinking that it would have been much easier to do this a different way to set this up, having this ERP variable be a matrix or maybe a cell array. And I don't disagree, except sometimes I think it's also useful to illustrate different coding strategies in Matlab. And so I probably wouldn't have done it this way if I were really writing code for an analysis. But for teaching, I think it's nice to sometimes do things that are seemingly a little bit bizarre or out of the way as a point of teaching. Anyway, let's run all this code and now we see that we get one. It looks like one line. So you can see the black line. You can kind of see the red circles and you don't really see the blue squares, but they are actually in here. How am I going to do this? I guess there's no really great way for me to illustrate this to you as it is. So I think if we zoom in to the very beginning up, you still don't see the. Oh, wait, I think you can see the blue line in here. Maybe if I make this line with one, I'll be a bit more visible. A. So the thing is that the blue line perfectly overlaps with the red line. You can kind of see that here. I guess one way I can illustrate this to you is by getting rid of some of these lines. I'm going to click on this cursor icon here and then click on the black line and that. And then I press delete and I'm going to click on the red line and then I press delete and the blue line stays. And of course, I can delete that as well. OK, so the point here was that these three methods overlap nearly 100 percent. They are a little bit divergent when you get down to the very edges. And the divergence is basically from this super trial method, so you get some edge effects here, which last for maybe 100 milliseconds or so, and otherwise they are basically identical. Now, if you're a little bit confused as to why these methods are all the same, in particular, option one, an option to the answer is that every operation we've done here is a linear operation. So filtering is a linear operation, or at least, you know, the way we have done filtering here is linear filtering and averaging is also a linear operation. And the interesting thing about linear operations is that the order never matters for linear operations. So you can filter and then average or average and then filter. And because it's all linear operations, the order doesn't matter. Now, if we were doing some kind of nonlinear filtering or any other nonlinear operation, then the order is likely to matter. So for nonlinear operations, order matters. But as long as you're sticking in the realm of linear operations, order doesn't matter.