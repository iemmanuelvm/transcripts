 I hope you enjoyed working on Project one, the peak to peak measurement, and I hope you found it a good challenge. So in this video, I'm going to walk you through my solutions. I've said in the beginning of many projects before that it doesn't matter if your code matches my code. What matters is you get the right solution. So as long as you've got the right solution, you generate the plot, you get the text results to print out. That's the important thing. All right. So now I will show you how I solved this. So loaded the sample data set. Identify this channel. And these are the peak times I call this variable neg peak time and pause peak time. And I'm using this search and to identify the indices in at times the Times vector that is closest to these time points in milliseconds. Let's see. So then here I compute the ERP. You may have discovered that when using the filter function filled filled matlab will give you an error message if the data are single precision. So therefore you need to convert the data into double precision that makes sure that you get more accurate filtering results and then plot the ERP. And then here is the patches. So actually, let me start running some of this stuff. So here you see the unfiltered ERP and now here I make a patch. And the idea of a patch is that you need to specify the X and Y coordinates of a polygon that you want to draw and then the color that you want to fill in. So the X and Y coordinates are for the negative peak time. And then here I'm saying the Y axis limits. That's just going to draw it from the bottom of the plot to the top of the plot. So I want to show you what these two vectors look like. So we have let me jump out the X again, make sure that they're underneath each other. OK, so these are the X coordinates. These are the Y coordinates. So you can see these are kind of seemingly initially mismatched because it's one, one, two, two. And here it's one, two to one. But actually what we're doing is identifying the four points. So this point and then this point and then the top right corner and then the lower right corner. And that's what this does. So this first element is going to be the lower left corner and then the upper left corner and then the upper right corner and the lower right corner. And then Matlab will draw a yellow face on top of that polygon. So that's going to look like this. Now, there's a couple of problems with this. First of all, I don't like this edge at this border around here, so I want to set the edge color to be none. Secondly, I don't like that this is a solid, opaque object. I would prefer to have this be somewhat translucent. So that's going to be the face alpha. And the other issue is that the patch is now plotted on top of the ERP, which makes the ERP harder to see in this area when it's underneath the patch, so that I'm going to change later. So that's for this. And then you had to fill in this. But this one isn't so hard. You just had to replace the variable names. So there we go. There's the green patch. And now this is a pretty weird looking line of code. But basically what I'm doing is flipping the order of all the objects in this axis. So an axis has multiple children. Those are all the things, the objects that are plotted inside of the axis. So here I say get from the current axis, all of the children. And you can see that that is a three by one array and its patch patch lines. So that corresponds to this patch and then this patch and this line. And then what I do is use this function, flip U.D. and flip updown. So that basically just swaps the order. And the effect of that is to put these two patches in the background and put the black line in front. So this now looks pretty good. And then we got some axis labels. All right. So this code was already there for you. Basically, a sync function is a sign of X over X. In this case, it ends up being a sign of times of sign of filt, times divided by time. And then you add this to PI times F, and that basically just gives you the frequency specificity. Now, it turns out that at the very center time point, you have an end value. And that's because at the very center you have sign of zero over zero that zero four zero. That's not really a useful number or it's not even a number. So this is one over zero zero zero. But so you're dividing by zero. So you get an end. And here I'm just finding that an end point and replacing it with the maximum value of the function. This is a amplitude normalization factor. OK. So this is called a sink function and let me plot what this looks like a figure and then plot fill time and fill out curd. So this is called a sink function. You can see that it still has relatively large values coming out here up until the edges. So therefore, we point wise, multiplied by one hand taper. And in case you are not familiar with the hunt, but I can show you what that looks like. So it just looks like it's a little bit like a Gaussian started zero or very close to zero. It goes up to one and then goes back down to very close to zero. So point wise, multiplication of the filter, the sink function by the hand window gives you a window to sink function. And that turns out to be a really useful filter. It's a low pass filter. So whatever frequency is specified here, that's going to be the cutoff for the low pass filter here. Now, in theory, you could make this filter col longer. That would give you a better spectral resolution. But we're not working with really long time series. We have a relatively short time series, so it's not possible to have arbitrarily long kernels here. All right. So this is nothing new. Main thing here is to keep in mind that you're going back to figure one because this was plotting to figure to. So now we get the unfiltered ERP and the filter to be all right. So now we get to the meat and potatoes of this project, which is really all about these lines of code here. Everything below is actually just copy pasting and a little bit of adjustments. So we need both the minimum and maximum peak values and we need to know the peak times. So I'm using the menu function and we want to search for the minimum of the ERP in between the. So let's see, this is ten points. Two hundred and seventy two time points. Two hundred and eighty five. And this is not ten points in milliseconds this time points in indices and now then that gets repeated for Max and then it's the positive peak time. So the thing that you have to be careful of is that this result, so this result is valid right off the bat. You don't need to do anything minus three point eight. And you can kind of visualize here that that's going to correspond to this point here. Now, this this value, this variable here, ERP meantime, this is six. And that might initially seem weird because if you look at the sixth time point in time, the six time point is minus nine hundred and eighty milliseconds, which isn't even on this plot. It's all the way out here on the left. Now the thing is that this is not the sixth time point of the entire signal. This is the sixth time point of this little window. So this here is the sixth time point since this yellow window on set. So therefore, it is necessary to shift this time point according to the windows here. So what you have to do is add the first window time point and it turns out that that's not going to be enough. That's still going to be one point off and I can show you that. So that is ten point two hundred and seventy six. And if we see what that corresponds to, that corresponds to seventy four point two milliseconds. And I'm going to zoom into this plot and we can see this is obviously the minimum. However, the minimum is not occurring at seventy four milliseconds. Seventy four milliseconds is, you know, somewhere up here. So what is that point? It's this point here, which is clearly not the minimum. This point is the minimum and it's happening at seventy point two milliseconds or thereabouts. So the thing about just adding the onset is imagine what would happen if the minimum occurred at exactly the first time point of this window. If that were the case, then adding the first time point would actually give you a result of plus one. So it would be one unit too much. So that's why you need to subtract one. Now we can see this again, so this ends up being seventy point three. OK, so I guess that it was seventy point two. You'll have to forgive me for my mistake. All right. So once you adjust those times, then computing the peak to peak result is pretty simple. We already have the values and you just subtract them and computing the latency difference is also pretty straightforward once you've dealt with this conversion. All right. So that's pretty straightforward. And now basically these six lines of code just get literally copied and pasted here. You just have to be really careful to change the variable names. So it's worth, I put it with a capital F everywhere to indicate the. That is for the filter thing, if I would say my most common mistake in matlab, the programming error that I make the most often, I'm sure it's just copying and pasting and forgetting to change all of the variable names. So something that I often do, which I recommend is if you're copying and pasting and you want to make sure that you've changed all the variable names appropriately. One thing I will do is start clicking on these variables up here and make sure that nothing gets highlighted. So you can see when I click on this variable, all the other instantiations of this variable, everywhere else with this variable is used that gets highlighted. So what I want to do is go and click through all of these variables and make sure that there's no highlighting in this section. So you can see I'll delete this just to give you a sense of what it would look like. So here, that looks fine here. So now I've clicked on this variable and you can see it's also showing up here. So that's my indication that that I made a mistake. All right. So that part's straightforward. And then this is also straightforward because this is already done for you. This is just about some filtering. So we want to have four significant digits in five places. And that's really, you know, just let me run this. That's really just to make the formatting look nice here. So it's lined up. OK, so then we get to this section where we repeat for Amien around the peak. And from looking in this simple example, you can see why computing a mean around the peak is better than just picking the peak. So this is an outlier. This is not representative. But if we were to average several points together, all of these points, you can see that that's going to be closer to this red line. So averaging is, of course, also a way of low pass filtering data. So this part involves a little bit more code compared to just identifying the peak here. But fundamentally, it's pretty much the same concept. So we have a window in time, in milliseconds that needs to be converted. So let me run this. That needs to be converted into sample points. So it turns out that if you want to get ten milliseconds at a sampling rate of two hundred and fifty hertz, you need to have two point five six samples now, two point five six samples is not possible. So you have the choice of rounding down or rounding up. And I think in this kind of situation, it's, you know, you can just round up. It's better to include one additional point that's only going to make the results be even more robust to noise. So then this is the actual window in terms of not in terms of time, but in terms of sample points, ends up being three. And remember, this is three on either side and three sample points is actually around twelve milliseconds for the sampling rate of two hundred and fifty six hertz. So in total, the actual window that we're using is the center time point plus or minus around twelve milliseconds. So it's around twenty five milliseconds in total. OK, so some of this is the same, the peak times are going to be the same and here I'm adjusting the peak times outside. So here I only had to do it once, so I just did it right in the code here. I'm doing it outside of the code in separate lines and out here you can see R.P.M. Rather than taking the output here, I need to specify it's going to be the average of the ERP from the center time point minus the window to the center time point plus the window size. OK, so again, more lines of code, but it's essentially the same operation as in the previous example. OK, and then finally, we get to the low pass filtered IRP, and this is really exactly the same code as up here, you just need to be sure to replace all of the instances of the variable ERP with ERP Filt. Oh, and I almost forgot to tell you the most important result. So other than the coding exercise, the important result from this project is to see the difference between a exact peak to peak, where the voltage difference of the peak to peak measurement, this feature of the ERP is really different. So three and a quarter volts, three and a fifth micro volts difference, that's quite a significant difference. You know, three micro volts is is this much higher on the Y axis between the filtered and the unfiltered IRP. So this means that taking a peak to peak measurement, using the exact peak time point is highly, highly dependent on the type of filtering, the low frequency cutoff. Basically, these small parameters of filtering can have really big effects, really significant effects on the peak to peak measure. But if you use the window around the peak, then it's much more robust. So you can see these two results are they're not identical, of course, between the filtered and the unfiltered LP, but they are much closer together. So this is one illustration of how taking a window around the peak is more robust compared to just taking the exact peak point itself.