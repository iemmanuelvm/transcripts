All right, so the rest of this problem set is all working with synchronization with the EEG data set

and in particular seated synchronization, that's what we are going to start with.

So we want to compute the synchronization from one electrode and we'll call that the seed electrode

to all other electrodes.

So we start by loading in the sample EEG data sets.

So that's called sample EEG data like this.

And then we perform wavelet convolution on all channels and all trials and we have to save the single

trial phase data and we don't care about the power data.

OK, so here we got you know, you remember when you're in school and you were learning about like the

universe and the scale of the universe.

And, you know, there's these facts like the total number of electrons in the universe.

I think that's probably something like this number.

Right.

Or maybe there's only one electron in the entire universe anyway.

I think that's just to get us to make sure that we're paying attention.

So frequency range, we are going to extract frequencies to implement synchronization between two hertz

and 40 hertz and we will get 50 steps and the number of cycles will go from three to nine in 50 steps.

This seems like a pretty reasonable range to me.

Of course, when this video is over, you are welcome.

And I encourage you to try playing around with different ranges for the number of cycles parameter and

see how that goes.

OK, so now we set up the wavelet and convolution parameters.

I already see Matlab is giving us a warning here, so we have to specify where time is going to be.

The time vector for the wavelet.

I'm going to set this to go from minus to that should be minus two to plus two.

Now unlike in the previous video in when I was working with the V1 data set.

Right.

Subtracted a sample point here.

This is already an odd number of points because we have a friendlier sampling rate, so we don't need

to do any weird stuff here.

OK, so then we specify the Frex variable, the frex vector of frequencies to go from the frequency

range one to two in steps.

OK, I'm just checking all of this stuff because you know that whoever writes this code, I have no

idea who that person is, but he has a devilish sense of humor.

OK, so let's see here.

We need to create the wavelets.

This is going to be a matrix of it's a little confusing because it's frequencies by frequencies.

But of course, this is frequencies for the wavelet and then frequencies coming from the Fourier transform.

OK, so we have our S parameter here appropriately normalized and then we have the wavelet.

So that is the complex sine wave E to the I times two pi f wav time and then we get to the Gaussian

and that is E to the minus.

We have time squared.

Divided by two times s, and that's also squared.

OK, very nice, and then we take without needing to normalize.

We take the end point 50 of the wavelet.

Now, I just wrote a bunch of code like this and I didn't really look at it.

So I want to make sure that this is really the right thing.

So there's a couple of things we can do.

One is we can just plot the wave time by the real part of the wavelet and this wavelet gets overwritten

at each iteration of this loop.

So this is just going to be for the final wavelet in this in this loop, which corresponds to 40 hertz.

Another thing is we can also plot the the power spectrum of the wavelengths and we expect that the power

spectrum is going to be Gaussian.

So I'm going to do this all at once in an image.

I'm going to make an image of ABSs, Wavelets, X, and this is pretty neat.

So let's see.

Let me do X is X Y.

So now what we have here is frequency's and these are frequencies and indices.

So this is not in units of Hertz.

And here this is the also frequencies, but this is now frequencies also in indices and not in Hertz.

But this is frequencies from the Fourier transform.

This is frequencies of the wavelet this these frequencies.

And you can see that they either shift their lighting to the right.

So they're getting the frequencies are getting higher and higher.

You can also see that they are getting wider and wider and now the color is also decreasing.

And that's because we haven't actually normalized.

So we can do this, we can plot.

And I think this is plotting in the wrong orientation here.

OK, so that was plotting the Cullum's instead of the rose here, so took a minute and then I just basically

transpose this so you see all of the Gaussians here.

So these are the frequency domain representations of the wavelets over different frequencies.

And because we haven't normalized the amplitude, you can see that the total the peak energy is actually

changing or the peak amplitude is changing as we get to higher and higher frequencies.

OK, so I just wanted to show you that as a bit of a F.A.A. and also because, you know, it's useful

for you to know different ways of visualizing these parts of the analysis.

OK, so we did this correctly.

That was the main point of that.

So let's see, initialize the matrix to store all the phase values.

So this is going to be channels by frequencies, by time, by trials.

Also a pretty big matrix here.

All right.

So now for the convolution.

So we loop over channels.

We get the spectrum of the data from this channel.

So this channel all the time points all trials and it gets reshaped to be a vector.

And we have the NT can point forty.

So this all looks good.

Then we are looping over frequencies and we take the inverse Fourier transform of the spectrum times.

A spectrum of the data times, the spectrum of the wavelet reshape that back to be time by trials.

And now you can also see them actually combining what I have traditionally in this course done in two

lines of code.

So one line of code would be to trim the wings off of the result of convolution and then in a separate

line, reshape into a time by trials matrix.

So here I'm just combining those things.

In fact, it gets even cooler than that, because if you want to, you can even put this line of code

in here directly and then we don't even need this thing here.

So you do the inverse 50.

Oh, man, this is getting even.

OK, this actually does have I was thinking we could put this in here, but we still need to trim the

wings.

So this does need to be a separate line.

Now, all of that said, this is a pretty even for me.

I tend to have some pretty long lines of code.

This is a pretty long, dense line of code.

So I wouldn't actually recommend going through all of this.

But it's just fun to see that that can work sometimes.

OK, let's see from all of this code ups to reshape the number of elements must stay the same.

OK, so there is a mistake somewhere and it's already right here.

I see what the mistake is.

We reshape the data and the data are NP data and not and command and confirm is actually longer than

the end of the data.

The tricky, tricky let's see now will run all this code again.

And now it's really working for reals.

And you might be thinking that we could make this be even more efficient by getting rid of this channel

loop and doing this over matrices.

Now, that is possible.

But as I mentioned at some point and some other video, it's not necessarily always a good idea to eliminate

the channel loop, particularly if you have a lot of data or a lot of channels looping through channels

is still a good idea.

OK, so now we have everything that we need.

We have this variable all phases, which is channels by frequency's, by time by trials.

All right.

So then we compute eskies to all and O.Z to all connectivity in the window of zero to six hundred milliseconds

in the alphabet.

OK, so let's work on that first.

So we want the time indices.

I see.

And then we are also going to need from the priest in period from minus six to zero.

So this is going to be decirte and IEG Times transposed, of course minus 600 to zero and copy and paste

and this is going to be zero to 600.

There you go.

That looks good.

And then the frequency indices, that's going to be the search.

And Frex also as a column vector transposed.

And then we want from eight to 12 hertz and we need to transpose there.

OK, so let's make sure all of that looks good.

OK, now we find the channels that we are looking for.

So this tells us the indices into the channel locations that corresponds to FC that and O.Z.

So then we need to initialize these matrices.

So let's look down and see if we can figure out what sizes these.

Things need to be so here's where we're using them here.

Notice it is a here we are getting one in Chennai and two in Chennai.

So this will need to be to buy channels matrices.

And what are these one and two is going to be?

Well, this is going to be from the two time windows for Alfa.

So this is going to be my minus 600 to zero and zero to plus six hundred.

OK, so we need this to be zeros and to buy that and be be.

Now this is going to produce a Matlab error because the zeros function only gives one output.

Now you might recognize this from what I introduced a few videos ago, and that is the deal function.

So we are going to take the output of the Xeros matrix and make that an input into the deal function.

And the output of the deal function is going to be these two matrices of zeros.

Now we want to compute the complex.

OK, so this is just, you know, this is what I typically call oilor rising.

So fz that oilor so let's start from the beginning or the middle.

I mean of this, of what we want the answer to be.

So this is going to be all phases and then we want F.C. Z, idex, idex and then actually let's let

me look at the size again.

So we have this as a reference.

So we want channel.

So the phases from Channel FC Z, from all of the frequencies and all the time points and all the trials

minus the same thing.

But this is going to be from Chennai and then this needs to be considered as one single set of vectors.

So this difference and then we say E to the I times this phase angle difference matrix, this ends up

being a big matrix here.

So and I think this is also going to be a singleton dimension.

Yeah, so this is also a singleton dimension.

But unlike what I did in the previous video, I think I'm actually going to leave this as four dimensional.

And then we will just have to keep in mind that we want to compute the average over the fourth dimension,

for example, to get the average over trials.

OK, so here this is now the same thing, except it is O.Z instead of F fz like this.

OK, and then let's run that, make sure that runs.

OK, now we want to compute I.

S PC seated synchronization over all time frequency points.

Now the idea, the motivation for doing this over all time frequency points is that we can do everything

in one line of code and then here we can separate it for these specific time windows that we are looking

for.

So we want FC Z oilor and then we need to average and what are we averaging over here?

So we are going to be computing synchronization over trials.

So we want to average over the fourth dimension and then we need to take the magnitude of the average

vectors.

So let's see what this gives us.

OK, so this gives us we still have an extra singleton dimension, but this is fifty by six hundred

and forty.

So this is frequency's by time.

So we can have a quick look at this.

I'm curious to see what this looks like.

So I'm just going to write Image Scale and here we are going to have to squeeze it, sink FC Z all and

this shows us let's spin it right side up.

So this is a time and this is frequency.

This is not Frequency's and Hertz.

These are indices.

And what you see here is, you know, there's some stronger synchronization, some low synchronization

and some higher synchronization.

And this is the synchronization between FC Z and Channel 64, wherever that channel is, I don't actually

know offhand.

OK, so then we do the same thing for O.Z.

And let's see, then we need to extract the average synchronization from the time frequency window.

So this is going to be sinc F.C. said, oh, it's a little bit of a bit of a misnomer here because this

isn't actually all this is really one.

In fact, this is going just to one channel, so maybe I'll even change this variable, name one.

And then here I will also change it to one.

OK, so F.C. said so from synchronization between FZ and one other channel and we want the well.

So this is where it starts.

Let me look at the size of this thing.

This is where things start to get a little bit confusing with Singleton Dimensions because we are going

to have to write one for the first dimension and then we want the frequencies.

I guess that I call it variable F idea.

Yeah.

So frequency from this frequency range and then from this time range to t idex one and then the first

element.

OK, so now this is going to be another matrix and here we want to average.

So we are going to average and average and then we want to average over the second dimension and then

over the third dimension.

OK, so that looks like this.

And now we're averaging that map that I just showed.

We're averaging over frequency and over time.

And now this is actually a linear averaging.

There's no nonlinearities at this step.

So it doesn't at this point.

It doesn't matter if you do two, three or three, two.

OK, and let me confirm that this works and also that it's just going to give us a single number, which

indeed it does.

OK, but now you can start to appreciate that these Singleton dimensions can get pretty confusing for

this reason, amongst other reasons.

So it actually probably wouldn't have been a bad idea to add a squeeze function up here.

But that's OK.

Let's see.

So now copy and paste, this is the same thing, except this is O.Z.

And then here we also copy and paste, except now we have to change a couple of things.

I have to change, of course, this from F.C. that O.Z and now this is actually so the frequency window

is the same and the time window is different.

So and now let's see, so we see these highlighted here and no variables here, these variables highlighted

here and not up here.

OK, and then these look good and these look good.

So I'm checking that I haven't accidentally overwritten any variables when I shouldn't have.

Cool.

Let's run all of this loop.

So that took around 15 or 20 seconds.

But through the magic of technology, I was able to cut it out.

So you don't have to just sit there waiting for me to wait for this thing to run.

OK, so now we want to plot.

So we are going to plot the all the various synchronization.

So let me just actually just run all of this code and then we can have a look at it.

OK, so here you see seated synchronization from FZ to all other channels and from O.Z to all other

channels.

This is pre stimulus, stimulus, stimulus, stimulus.

And then this is the difference post minus Prae.

So the first thing that you notice here is that the synchronization is really strong near the seed electrode

and it gets weaker with increasing distance away from the seed electrode.

You see that in all four of these maps.

That is one of the hallmarks of volume conduction artifacts that I discussed in the first or maybe the

second video of this section.

And one of the things that I suggested, one of the strategies that I suggested for attenuating the

effects of volume conduction in phase synchronization analysis is to look at a kind of connectivity

differences between time windows or between conditions.

And that's what you see with these plots here.

So this doesn't guarantee this different plot, doesn't necessarily guarantee that you are going to

eliminate volume conduction, but it does really reduce the influence because presumably the volume

conduction is basically the same in these different time windows.

But the functional non volume connection on artifacts or connectivity is actually different between

priest and Postum.

And in fact, when you look at these differences, you see that it's basically zero and immediately

surrounding the seed electrodes here.

And so what differs is likely to be real.

OK, so now let's see.

So that was number two.

Number three is to adapt the code above to use the phase lag index instead of the phase clustering and

put it in a different figure so you can compare them.

OK, so let's put this one in figure four and then let's see what do we need to do here?

Well, we actually just need to change these guys here.

So all of this is fine.

All the code everywhere here is fine.

All we need to do is change this formula very, very slightly.

And I trust that you remember that the main difference between site phase clustering and the phase like

index was we need these two nonlinear functions before we averaged together.

So the first one was to compute the sign.

And what do we want to compute the sign of?

That's right.

The projection onto the imaginary axis.

So that goes like this and then repeat that here.

So this is sine and image like this.

And let's see.

OK, so I'm pretty sure that I've done all that correctly.

So I'm going to now, let's see, rerun all of this code, rerun all the plotting code.

It's going to go in figure for.

All right.

And so the first thing that's immediately apparent is that these maps are all blue, these are deep

blue and these are more color.

So what's happening here is that the synchronization values are going to be much smaller because we

have eliminated all of the volume conduction artifacts.

So these maps here show a combination of true synchronization and volume, connection, artifact, and

these maps only show the true synchronization.

So I don't know offhand what is going to be a good color limit, but let's just try to point to and

OK, that looks pretty good.

Maybe, but I'll leave it at point to.

OK, so let's run all these plots again.

And I didn't change the different color scales.

Those were all the same.

OK, so it's pretty interesting to compare.

In fact, they look quite different.

Even the different plots look really different, surprisingly different between the two.

So this one is is red in the back where this one is blue.

If you recall the video where we first compared phase clustering to phase lag index in this data set,

this empirical data set, you will remember that when we computed with average reference the average

reference synchronization between I think it was FZ and and.

Between those two electrodes, it was all white.

You remember that it was really, really high values everywhere and we couldn't interpret it.

And then we discovered that the lipless with phase clustering looked more similar to the lipless in

with the phase lag index.

So here is the question for number three is what do you think of the results?

Well, you know, on first glance, they look really different, almost frighteningly different.

You know, it's like even the total opposite effect.

But I really believe that these results with PLI are trustworthy and these results with just the phase

clustering are and the average reference without doing a little plasty in reference, these results

are not really to be trusted.

And so that leads us to number four, which is to adopt the code above again, but this time use the

lipless in instead of voltage.

So let's see what we need to do.

Let's see where is the best place to do this.

So I guess, first of all, computing the positive right.

When we load in the data seems like a good place to do this.

I'm going to write Lipless in Parent X, and then this was EEG, that data EEG, that Chinelo X EEG

that looks that Y and EEG that channels that Z.

OK, so here we compute the placea and then the question is, where do we need to replace EEG data with

EEG that lap.

So it definitely has to be done here.

Exactly.

Here.

OK, so EEG lap.

So let's do that first.

We don't need to recreate all the wavelets and then redoing the connectivity that needs to be recompute

it, of course.

But we don't need to change any variables.

We do need to change the figure numbers.

That's going to go into figure five.

So let's see where do we need to run?

So I did this part just now.

So now I'm going to redo all of the connectivity and the plotting.

Oh, and, you know, this was actually the lipless in with the play, and I wanted to do the lipless

and actually what did the instructions say?

Adapt the code again, using the lipless instead of voltage?

Well, actually, the instructions didn't really say whether we should do this with the phase clustering

or with the phase lag and without really thinking too much about it.

I did it with phase lag.

So let's just visually compare these two guys.

And it's interesting to see that some of these features are the same.

So if you just pick one map as I go back and forth between the average reference with PLI and the plussing

reference with PLI, you see that many of the core features are the same.

But the look policy and map looks much more localized.

These effects look much more local and focal compared to the average reference with the play.

OK, so if you would like and of course I recommend doing this, you can go back and change this code

here basically to get rid of these two functions here.

So you're going back to phase clustering instead of phase lag index and then that will give you a fourth

figure.

And then it will be interesting to compare all four of these figures similar to what we did several

videos ago.

OK, but I am going to move on to number five.

So let me close all of these guys.

So number five, in this exercise, we are going to compute time, frequency maps of inter site synchronization.

And this is going to be synchronization phase clustering between FC Z and O.Z.

And we are going to compare qualitatively the raw connectivity with the baseline subtracted connectivity.

So let's get started.

We want to define a baseline time window.

So that's going to be decirte end times and we use minus 500 to minus two hundred.

And then here we extract the connectivity.

So we actually don't need to adapt the code above because we already have these.

I believe if I remember correctly, it was called all phases.

Yes, all phases.

So let's look at the size of all phases.

OK, so we can recompute the connectivity from this variable.

We don't need to worry about the fact that we've already changed this code for plot here.

OK, so we get the phase differences and this is going to be the Euler's formula applied to the phase

angle differences.

So this is all Phases four and FC Z and O.Z.

So we already have variables that tell us the indices of these two channels.

So this channel and then we have all frequencies all the time points of trials.

And I'm reading that off of this matrix size here, minus all phases, four oh oh that idex all frequency's

time points and trials and OK, so this gives us the phase difference then we want the synchronization

which is essentially OK.

So I'm going to and I'll put a squeeze in here because why not.

You can put the squeeze outside here, you can also put the squeeze in here.

So now we have a three dimensional matrix.

OK, so now we want synchronization over trials.

So this is going to be ABB's mean and then we want phase diffs and we want to average over the third

dimension.

So that's going to be third dimension like that.

And let's make sure this is a two dimensional matrix frequency's by time and then we want to extract

the baseline time window.

Sorry, actually this is the whole map of synchronization that is baseline corrected.

So let's see, I'm going to use BSF fun for this because that's one of my favorite matlab functions.

So sinc ra and what are we going to subtract.

We want to say this thing minus the synchronization in the baseline time window for each frequency separately.

So let's compute the baseline frequencies using mean uh let's see sinc raw and then we have all frequencies

and the base uh idex one to base idex two and then let's see, of course we are averaging over the second

dimension which is time.

OK, and before actually looking at this, I am curious though the thing about baseline.

Fraction of connectivity, data of synchronization data is that phase synchronization is not subject

to, oops, let me run this same phase.

Values are not subject to the one over EFF that you see in power values.

So you don't necessarily need to apply some kind of a normalization to get rid of the one over effort

to deal with this one over issue the way that you do with power.

So here what we're looking at is the synchronization levels in the baseline period and they do not follow

a one over Heff period.

In fact, it looks just kind of noisy with a really large value here at the lowest frequency.

If anything, it looks like the synchronization is increasing.

So this is like just, you know, F instead of one over F, however, baseline subtraction of synchronization,

data of connectivity data can still be useful.

It can still be informative.

And that is because it is reasonable to expect that there's going to be synchronization before the trial

starts in the baseline time window.

So then you want to see how the synchronization is changing over time, which is still an interesting

question, even though we don't need to worry about all this one over business.

OK, so let's run all of these three lines of code and then we do some plotting.

So we're going to plot the overall synchronization and the baseline synchronization and notice that

the colors are the colors are going to be different here because the raw synchronization is cannot be

negative, of course, because these are magnitudes these are lengths of lines.

So the raw synchronization cannot be less than zero.

But of course, baseline subtracted synchronization can be negative.

We don't really see negative values here, but if it were negative, it would mean that there was strong

synchronization in the baseline period, which then decreased during the trial period, during the stimulus

period.

And in fact, we even saw an example of that in the previous video when I showed the time course, lots

of synchronization and V1 at eight hertz.

OK, anyway, so you see the maps don't really change all that much for the raw and the baseline subtracted.

I think they look a little bit cleaner here.

I think it looks a bit nicer here, but overall it looks pretty good.

I would say nice.

So that is done.

We are done.

And that was the end of the problem set for this section.

I hope you enjoyed and learned a lot from this section of the course on synchronization.

You can see that synchronization is tricky business because there are so many possibilities.

There are many, many ways to compute synchronization in multichannel data.