Of course, you know my feelings about simulating data to evaluate data analysis methods, I think it's

great.

It's a great idea.

You should always simulate data to understand the data analysis methods that you are interested in applying.

And so in this video, I'm going to show you one method to simulate EEG data, or I should say data

in general time series data to evaluate and understand connectivity methods.

There are, in fact, many ways to simulate data with connectivity structure.

So this video is just going to be one particular method.

And I will then show you an application of applying these simulated data to understanding both the play

and the phase clustering measures.

So we are going to simulate five seconds of data at a sampling rate of one kilohertz, one thousand

hertz.

And then this is important.

We have parameters that we can specify and for our purposes here, what the application that I will

show you in this video, these are going to be the two most relevant parameters.

So this is the phase lag and this is the noise level.

Now, notice how I've defined this phase like it is point of five times to pay.

So what that actually means is that I'm allowing you to specify the phase lag in terms of a fraction

of a cycle and then it doesn't actually matter.

You know, you don't need to specify the time lag.

You don't have to specify the exact phase lag in radians.

Instead, you consider that this is going to be the phase lag in proportion of a full cycle.

So here we are going to simulate two signals that are oscillatory, they will have a frequency of seven

point three hertz.

And the phase lag between those two signals is going to be five percent of to pay.

OK, so here we generate the two signals.

So that is a sine wave.

So to pay F.T. And then there's a big space here.

But that's just to just for like nice visual alignment.

And then here in the second signal, it's the same sine wave, same frequency.

And I'm just adding a phase lag here and this phase and then we add random noise.

The question is, how do we add this noise?

So here we are or what to do with this noise level variable, really?

So we're adding unique normal noise to each signal and then we have a couple of options.

Well, I guess there's you know, we could do like it could be plus it could be divided by it could

be to the power of.

I think the right thing to do here is to say multiply.

So we are going to scale this random noise according to the noise factor here, which by default is

one.

But you'll see later on in the video, I'm going to change that to explore the effects of noise on phase

synchronization measures.

All right.

So now we have our signals and let us plot them.

So let's visualize these things.

So let's see.

We have this the time vector is called time.

So I'm going to plot them as time, comma sig one.

And now if you want, you could do you know, you could say hold on and then plot time to totally fine.

But there is a shorter way to do this, which is to use the plotting format, the plotting input format

of X come away comma X comma.

Why.

So this is going to plot both signals with the X and Y axis coordinates on in the same line of code.

So it's just a little bit more efficient.

All right.

So here you see what these two signals look like and we can zoom in a bit.

So they're clearly sinusoidal.

That part's really clear and then it's noisy.

It's also clear.

It's a very simple signals.

And you can also kind of see that signal.

One is a little bit delayed.

So there is a little bit of a phase lag between them that is apparent.

Let's go back to the original view and now we are going to compute phase clustering.

So HSBC and phase lag play.

So this is going to be we're going to go from frequencies twenty to three hundred now in four steps.

OK, so let's think about whether this is a really sensible range of parameters.

First of all, it does so.

So one question we can ask is whether this range of frequencies is even valid.

And the answer there is yes, because the sampling rate is a thousand hertz, so we can actually go

up to five hundred hertz.

So this is a valid range of frequencies.

However, it doesn't really make a whole lot of sense, of course, because the sine wave is at seven

point three hertz.

So why don't we change this about two to, I don't know, maybe let's go for like 15.

How about that?

And.

And 40 steps, that's maybe a little bit excessive to go 40 steps between two and 15, but I'll just

leave it like that for now and OK, fine, I'm not I'm going to change it to 13 because that's the higher

frequency, minus the lower frequency.

OK, and here we set a range for a variable number of wavelet cycles.

So this is not a range.

This is just a single number and that's also fine.

But the instructions do say to set a range.

So I'm going to go from so linearly spaced numbers.

Let's go from how about a wavelet full with the half maximum or Gaussian forward to the maximum of 400

milliseconds at two hertz.

And maybe we will go up to, how about two hundred milliseconds at 15 hertz?

Now, these are parameters.

There isn't really a specific way to know what the right set of parameters is.

It depends a lot on the data in a really, really simple system like this, where you have a continuous

sine wave, continuous synchronization and more or less stationary signal, then it's actually better

to lean towards a higher a wider Gaussian because that gives you better frequency precision.

So I'm going to change these variables a little bit later on in the video.

But for now, we'll just leave it like this.

OK, so then here we specify some other parameters for the wavelets and here we have the FFT parameters

for convolution.

And oops, I didn't run all of this code.

So let's see.

That looks good here.

We take the 50 of these signals and here we are initializing the output matrices.

And these are actually just vectors.

And let's see.

So here we loop over frequencies, we create the wavelets.

And, uh, let's see.

So this is now this is now listed as a single variable.

However, we know that this is a vector, so this needs to go f I what I call this would be if I now

I look at this, I see this is one hundred elements long.

Why is that one hundred elements long.

This should be uif.

I forgot to specify the number of increments between point four and point two.

That should be num frex.

All right.

So that looks better.

Now we have thirteen elements here.

OK, so this part then looks good and now we need to take the spectrum of the wavelet.

So that's the F.T. of the Wavelet and of course it's Encarna points long, not the default, which would

be whatever it would be.

And do we need to normalize the wavelet here?

The answer is no, because all we care about are the phase values.

We don't care about the amplitude.

OK, so we have our wavelet and then we do convolution here and oops, what am I missing here?

I didn't specify this looping index here.

Let's see now we have our wavelet and we run convolution convolution for signal two and now we want

to collect the oil erased phase angle differences.

So this is the angle of as one minus the angle of as two.

And then we want to embed this phase angle difference between our inside Euler's formula.

Now, I have already explained in the previous couple of years ago that code like this seems like it

should be correct, but unfortunately it's wrong because the imaginary operator is only multiplying

this variable and not this variable.

So we need another set of parentheses here like this, and then we compute is and play.

So let's see, this was the average vector from all of these complex vectors.

And then we take the magnitude of that average vector.

And this has averaged over trials.

That's actually not correct.

That's just copied and pasted from somewhere else.

There are no trials.

We don't have any trials here.

These are just one single trial for this signal.

OK, and then the plot, I remember it almost look like this.

I think I'll even start like this.

And then there was a couple of extra steps in here.

So before we take the average, we first have to extract the signs of the projection onto the imaginary

axis.

So let's see if I'm going to run all this code and keep my fingers crossed.

All right.

That worked.

And it went super duper fast.

OK, and then let's see.

So I'm going to run this plotting code again so we get this plot again.

Let's see.

So there's that.

And then here is the spectra.

So this is pretty neat.

What you see here is.

A spectrum of frequencies on the x axis, synchronization strength on the Y axis, and we see basically

perfect synchronization with both measures at around seven hertz.

Now, I think we don't actually have exactly seven point three hertz, which is the frequency of the

wavelet.

So I think I actually will run this up to 40 because why not?

This code all runs really fast.

So I'm going to rerun this code here.

And same result, of course, it's just a little bit smoother because we are getting additional frequencies

here.

All right.

So I would call this a positive result for both of these measures.

We simulated connectivity and we got connectivity.

We got really strong synchronization using both faiths, clustering and phase lag.

Now, you'll notice that this is a little bit wider here, but that's actually because of the width

of the wavelet.

So it is interesting to change this, the parameter of the wavelet here.

So what I'm going to do is increase this.

Maybe I'll make this point six to point six.

So it's actually just constant point six.

And then, you know, it's just in Lin space here mainly just so I don't have to change the code later

on.

Let's see.

So then I want to put this in its own figure.

So I'm going to say figure 11 and it's just going to facilitate direct comparison.

So let's see where I change.

This guy needs to be rerun.

OK, so this is pretty interesting.

You see still the same positive value at a little over seven.

And now this is narrower here because the wavelet was wider in the time domain, which means we get

more precision in the frequency domain.

It means we get less precision in the time domain.

We get more smearing in the time domain.

But in this particular case, we don't even care about that.

OK, so let's see what was the question here?

So the first question is, what is the effect of the phase lag parameter on the results?

OK, so what I'm going to do is, first of all, C comment this out.

So I'm going to get rid of this figure here.

It's going to be overridden and I will set this back.

Why don't we go to like how about was it before it's two point four to point to.

OK, so what I want to do is change this phase log value.

I'm just going to make it much smaller by setting the phase like to be instead of point three, it's

going to end up being much smaller.

So now it's zero point zero three.

Let's see.

So this code needs to be rerun.

I need to recreate the signals, of course.

And that was not an error that I expected.

I wanted to try to redefine time.

And let's see, where do we go wrong here?

I see, oh, this is bad programming on my behalf, I use the same variable here, the same name for

variable, but it means totally different things up here and down here.

So here Frex is a vector and here Frex is a scalar that is bad programming.

I feel I feel shame and embarrassment right now.

Why don't we change this variable name to Frech for Sig.

So it's the frequency for the signal and then I have to change it here of course and change it here.

And then we rerun this code and let's see, rerun all of this.

I remember what I changed here other than fixing that bad coding incident, was that the phase synchronization

lag is now really, really small.

It's very close to zero.

And what you see is that the play basically went to zero.

It looks like there's a bit of a peek here, but it's hard to know whether this is a real peak, reflecting

the true synchronization at very not zero lag, but very, very close to zero lag or whether this is

just a little bit of noise, because you can see, you know, it looks like a relative pick here, but

it's also almost as strong here.

But anyway, the play got very small and the phase clustering stayed really high.

So this was a case where we see a beautiful dissociation between phase clustering and phase lag.

Now, this is not a bug.

This is a feature.

The phase like index is designed to be suspicious of any connectivity that has zero or very close to

zero phase lag.

OK, so now I'm going to set this back to, let's see, point oh five, how it was initially.

And then what we want to do is for the second question, set the noise level to be high so around 10

and run through the simulation multiple times.

Do you notice any differences between play and ISPCC?

OK, so set the noise level to ten and now rerun.

I just rerun all of this code and what we want to do essentially is see how sensitive these two different

measures are to this level of noise.

So one thing that's that's a little bit terrifying is that the peak is now at three hertz, around three

hertz for both of these.

And then we still see a peak at around seven.

But it looks a little bit fast, faster than I then we would have expected when we have a lot more noise.

So now I'm going to run this again and now you can see.

So in this case, the phase clustering still identified the synchronization, although it's it's reduced

in magnitude and the play totally miss it.

In fact, if you're just looking at the play, you know, you would say, oh, there's synchronization

at 11 to 12 hertz and it's like upper alpha range.

So let's run this again.

And here we get a kind of similar result.

So reduced synchronization magnitude with this amount of noise, but it's higher for phase clustering.

It still looks like a peak here for phase index.

And here's a pretty nice case.

They were equally well estimated with two methods.

Here is another example where you get a pretty decent, pretty noisy, robust estimate using phase clustering

and not much from phase index.

OK, so I'm going to stop this here.

Now, I'm not doing, like, really rigorous, thorough investigations of the effects of noise magnitude

on phase clustering versus phase like index.

You could do that on your own.

That would be a pretty interesting exercise.

You could essentially, you know, do what I'm doing here, repeat this analysis and measure the synchronization

strength.

But you would want to do this, let's say, a thousand times with different noise estimates each time.

And then once you do that a thousand times for this level of noise, you could do it another thousand

times for a different level of noise and so on.

And when you repeat this many, many times, that will give you a better understanding of the sensitivity

of phase clustering versus phase lag index to the amount of noise in the signal.

That's a pretty important thing to know about these different analysis methods.

Anyway, my primary goal in this video was to give you a tool for simulating synchronization data that

you can use for evaluating data analysis methods like what I illustrated here.