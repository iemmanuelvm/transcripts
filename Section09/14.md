 The purpose of this video is to translate the concepts that I explained in the previous video into Matlab code in particular, we are going to be computing synchronization phase synchronization at 44 hertz between channels one and seven of the V1 data set. We will store all the phase angle time series for all time points in our trials and then we will compute and visualize phase synchronization over time and over trials separately. All right, very nice. So let's see. We load in the data set and extract some convenient variables here. And let's see, here are the channels for connectivity and create the wavelet. And I think this all looks good looking through this kind of quickly. So we're using a the wavelet formula or the Gaussian formulation based on the number of cycles with ten cycles. So it's just a parameter. Of course, you know, you can change this, but I think we can just leave this at ten for now. OK, and then here's the FFT parameters also looks good. And then we take the spectrum of the wavelet, initialize the output time, frequency data. So this is going to be we're going to store all the phase values. It's going to be to four channels by time, by trials. OK, so here we get the analytic signal, the result of complex Morleigh wavelet convolution for Channel One. So we have the FFE, the end point fifty from this channel all time points all trials and reshaped to a vector. So that part looks good. And then I think all of this part looks good as well. All right, then we collect all the phase data, so we're only interested in the phase angles in this particular video. OK, now we need to repeat this for Channel two. So I'm going to copy and paste and let's see this changes to a two really important change. And the wavelet, of course, doesn't change and these variables can all stay the same and. All right, that looks pretty good. So now we want a matrix of phase angle differences. So we are going to compute the difference between Channel two and Channel one. Index two and one, of course, that's channel location seven and one. And you already know from previous videos that the order does not matter. The phase synchronization is a symmetric measure of synchronization. So we could also write to minus one and that will give us exactly the same results. All right. So that's good. And then we want oilrigs for convenience. So essentially what we want to do here is put this in embeddedness in Euler's formula. So phase diffs like this. OK, now, of course, you could have also just put this directly up here. It's probably even a little bit easier, but that's OK. All right. So now we are going to plot we want to compute phase clustering over trials. So now this part is missing and this is phase clustering over time. So we need to figure out basically which dimension do we average over. So let's think about this. This is a time by trials matrix. And if we are going to compute clustering phase clustering over trials, then what we need to do is average over the different trials, of course. So then we average over the second dimension. And the result here is going to be the length of time. So we get one value per time point and that corresponds to the clustering of phase angle differences over trials at each time point. And therefore this is going to be averaging over the first dimension, which is the time dimension. So this is going to give us one value per time per trial. I said that wrong. Sorry, this is one value per trial, reflecting the synchronization over time within each trial. OK, so let's make a plot of all of this and make sure that this looks good. OK, so here you see this looks rather smooth, right? This is the phase synchronization over trials between these two channels and it goes up here after the stimulus and then it goes down a bit and then it seems to go up a bit here again. Now, this result here clustering over time. Notice that the length of the x axis is different. So this is just 210 time points corresponding to two hundred trials are two hundred data points, so not two hundred time points. Now, why is this one so jaggery? This one almost looks like a bunch of random. No, this one looks really nice and smooth. Well, that's actually not that surprising. This is the change over time. So, of course, there's going to be a lot of autocorrelation, temporal autocorrelation in this Time series data. Part of that autocorrelation comes from the smoothing, the temporal smoothing that's imposed by the wavelet convolution. But also part of that is just intrinsic to the way the brain works and synchronization. If you have strong synchronization at one time point, you're pretty likely to have strong synchronization or at least correlated synchronization magnitude at neighbouring time points. And here we are looking at different trials so each trial can have a different synchronization magnitude. Now, it's also pretty interesting to think about how much variability there is here. So some trials, there's very, very little synchronization. There's really, really weak synchronization and some trials. There's really strong synchronization like this is over point nearly zero point seven. That's actually quite strong synchronization. That's basically the peak of this synchronization here, like how the maximum synchronization here is for this trial, the average synchronization of the entire trial. So that's quite strong. So why is that the case? Well, I don't know. It could be just natural variability. There could be some some noise and measurement error in here. And maybe this is also meaningful. If you were doing some kind of a cognitive task, you might want to know whether these changes in synchronization over different trials are related to some aspect of the behavior on those trials. Maybe it could be that the trials where the synchronization was stronger were trials where the research participants made a decision about the trial stimulus faster. So this is the kind of variability that you might be interested to relate to trial variability in behavior or different measures of brain dynamics or heart rate dynamics, or who knows what your experiment is about. Nonetheless, I hope that this distinction between synchronization over trials, which gives you a synchronization at each time point and the synchronization over time, which would give you for a task based design that would give you a synchronization magnitude, a synchronization value for each trial. I hope that distinction is now clear. You can see it's a tricky distinction to make because the formulas are almost exactly the same, except for which dimension we are computing the average over.