 In this video, I'm going to introduce you to time frequency analysis via Wavelet Convolution by showing you how to create a family of complex Morleigh Wavelets. So these are Morleigh Wavelets because they are a combination of a sine wave and a Gaussian. They are complex because they have both a real part and an imaginary part. And there's a family of them because the wavelets share similar properties, but they change over frequency. So it's a whole family of complex Morleigh wavelets. So let's start by specifying some of the simulation parameters and we use a sampling rate of one thousand twenty five hertz. People often use one thousand twenty four because that's a power of two. But today feels like a 25 day. So and I'm going to use twenty one points. It's useful for convolution and for wavelets to have an odd number of points. That's because when the wavelet has an odd number of points, it's going to have an exact center point. And that's convenient for making sure that the result of convolution is perfectly aligned in time with the original signal. And then here I'm creating the time vector. This is a slightly different way of creating the time vector than what I usually do. So typically I do something like this that it's like, you know, it goes from zero to end points, minus one divided by the sampling rate. So first of all, this is not going to give us a symmetric time vector that starts at zero and it only has non-negative values. Now, you could subtract the mean from this and get it to be around zero. There's many ways to create a time vector here. What I'm doing is specifying linearly spaced numbers to go from minus one to plus one. Now, this on its own is not an appropriate time vector because the sampling rate here is not going to be the same as this sampling rate. So therefore, I have to scale this arbitrary vector according to the sampling rate, and the reason why I divide it by two is because we have the same number of points positive as there are negative. OK, so our Wavelet family is going to go from two Herts up to fifty four hertz and there's going to be 99. Here I'm specifying the exact vector of frequency, let me run some this and show you what it looks like so the frequencies themselves will be these numbers. So it starts off at two hertz and then the second wave will have a central frequency of two point zero six eight four. And it's probably some other numbers after this. Hurts and so on, and finally we get up to 50 for her, and you can also see that these are logarithmically increasing because, for example, the distance between the first and the second wave is very small. So point six. And then by the time you get to the end, the distance between these two is nearly two hertz, around one point eight hertz. I want to show you briefly how to use this log space function, because it's a little confusing. Using the lens based function is easier if you want linearly, let's say, for linearly spaced numbers between one and two. That's how you do it. So you get four numbers there, linearly spaced, and they go from one to two. But if you were to do the same thing, but with the function log space, you would get the numbers 10 up to 100, which may initially seem weird because ten is not equal to one and two is not equal to one hundred. However, ten turns out to be. Tend to the one and one is tend to the two. And in fact, that's what the log space function is doing. It's not creating logarithmically space numbers between this and this. It's between 10 to the this and 10 to the that. So therefore, if you actually want the numbers one and two, you have to scale these down by a power of 10, so you do log 10 of one and log 10 of two. And that's actually going to give you the result that you want. So logarithmically space numbers between one and two. All right. Now we are going to be creating more than wavelets using both formulas that I showed in the previous slide, and I've also introduced you to these formulas several times before in this course, in particular in the first section on simulated data. So we're going to use a number of cycles and that's going to change from three to 15 with increasing frequency and also the full with that half maximum. And that will decrease from one second to three hundred milliseconds with increasing frequency. Here is the loop where I create the wavelets themselves, so I initialize the Wavelet family, we need the number of frequencies by the number of time points and then two, because we have two ways of creating these wavelets. All right. So inside this loop, we create the complex sine wave. So it's E to the I this is Euler's formula here and then the decay part. So what goes into Euler's formula is the innards of a sine wave. So two pi F times T. Then we create the Gaussians. Here's one Gaussian, you see E to the minus T squared over two squared where X is defined as the number of cycles divided by two by F, then here's the other Gaussian formula. So you still see the E to the minus T squared over something squared, but now the formulation is just a little bit different. So we have a factor of four log two in the numerator and we don't need the two anymore in the denominator. OK, and then creating the wavelets themselves is pretty straightforward, we just say the complex sine wave multiplied by the Gaussian. So run this code around the oldest code and here we do some plotting and I'll show you what this looks like. So I'm creating maps of the real part of the Wavelet family, the imaginary part and the magnitude. And so those you see here, the real part, the imaginary part and the magnitude. The real part corresponds to a cosine and you can see it's an even function because the colors are mirrored on both sides. The imaginary part corresponds to the sign. It's an odd function. You can see the colors are opposite on both sides of zero. And the magnitude is just the analytic envelope, the amplitude envelope. So it creates this kind of nice pattern, like it's shooting off into the distance. And that's because frequency is on the Y axis here. So naturally, these wavelengths are getting faster and faster and narrower and narrower with increasing frequency. So here you see for the number of cycles here, you see for specifying the galaxy and according to the full with that half maximum. Now, these are not identical. You can see that for specifying the galaxy. And with full with and half maximum, it's a bit wider here. It's a bit narrower. This is not anything that is meaningfully intrinsic to these two different ways of specifying the Gaussians or these two wavelets. This is really just about the parameters that I happen to pick, and when I pick these parameters, I was not explicitly trying to match these, so I wasn't trying to get these to be identical. But you actually can get these to be identical. And that's because this formula for the Gaussian is not fundamentally different from this formula for the Gaussian. You can derive one from the other. They're just different ways of expressing the same function. Recently, I've come to prefer this approach because it makes the full with it maximum really clear, and that is a more intuitive way to parameter as a Gaussian compared to the number of cycles, which I find is a little bit less intuitive. OK, so here's what these three parts look like, and then the last thing is to show an example of one wavelet. So here you see the image. Each line, each row in this matrix corresponds to the wavelet at one frequency. And now I'm going to show you basically the time by these different components of the wavelengths. So here in blue, you see the real part again, that corresponds to the cosine part. And red is the imaginary part of the complex wavelet. And this thin black line over here, this is the magnitude, the absolute value. That's the analytic envelope. So now you can look at these lines and match that back onto what you see in these images here. OK, and here's for the number of cycles and here's for specifying as the full with that half maximum. And this is seven point four hertz. And that's really just because I happen to pick wavelet number 40, more or less at random. Again, these are not identical. You can see this wavelet is wider, but that is not something that's fundamentally different between these two ways of setting up the Gaussian. It's really just because I didn't bother to adjust the parameters to get these to match. So if you like, you can try changing these parameters. You might have to change one from a space to linearly spaced and see if you can get these parameters or these resulting functions to match more closely based on your parameter settings.