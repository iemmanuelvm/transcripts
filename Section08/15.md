 So now I'm going to walk you through my solutions and I will try to resist the urge to remind you that it doesn't matter if your code matches my code. What matters is that you are gaining experience, working with neural data. Time series analysis and that you are solving the problems as opposed to making sure that the code looks good. OK, I won't say that out loud anyway. So here we get started. We load in the van laminar data set. Now I picked Channel seven, so you should also use Channel seven if you want your results to look like mine. But of course, it's interesting also to compare different channels and see how the nonferrous locked in the phase locked power spectrum looks different. All right. So these are the wavelet parameters that I used from three to 80 hertz in 40 logarithmically spaced steps. And I see this stuff is not super interesting. Uh, and the FFE parameters, this is basically all fixed. You don't really have a lot of leeway here for specifying these. So here we can be DRP as the average of all the trials, so average over the dimensioned three of so over all the trials for all the time points at this one channel. Now, you'll remember from the video on into trial, phase clustering before and after removing the ERP, that in that video I showed that there were two ways to subtract the ERP. In other words, to get the nonferrous locked part of the signal. I showed it using a double loop and I showed it using the best fun function. Here I'm showing you a different way, not because I no longer like the function. I still really like the best X1 function, but it's just generally useful in matlab to see the same procedure implemented in many different ways. We're not even in Matlab, just in life in general. OK, so what I'm doing here is saying the data for this channel all the time points all channels minus Redmap. So repeat matrix of the ERP and I repeat it by one by the size of sixty three, which means the number of trials. And then here I transpose it. So this all looks quite confusing. Let me load in this data, set that to be in the right direction. OK, loading the data set. Now let's compute the ERP and now you can see the ERP is a vector, it's a row vector. That's fifteen hundred and twenty seven time points long. Now sometimes in Matlab it doesn't matter whether you have a row vector or a column vector. So let me show you size ERP. So this is a row vector because you can see that it's one by fifteen hundred. So that means it's one column down and 1500 sorry, one row down and 1500 columns long. So this is a row vector and you can also see that when I mouse over, you can see that it's really long. In contrast, we would say the size of the ERP transpose. This is now a column vector because it's 1500 points down like this and then it's only one column across. So this is going to be a total vector now sometimes in Matlab. It doesn't matter whether you're dealing with a row vector or column vector, for example, when you're plotting, but sometimes it does matter. And in this case it actually does matter. So we need to reproduce this as well. So let me actually start by showing you the size of this, and I think then it will make more sense. So the size of this that we are subtracting from is 1500 by two hundred. And so what we want to do is create a matrix. So repeat this vector ERP so that it goes into a matrix that is also fifteen hundred by two hundred and then we can simply subtract them like this. So now in order to get the ERP, which remember is initially a row vector, in order to get this one by 1500 array into a 1500 by 200 matrix, we first need to rotate it so that it's 1500 by one and then we can repeat this. Column vector two hundred times, and that is why this is the right thing to do. OK, so we can run this and that works, and now I just want to show you, I think that the most commonly asked Matlab question is what is the deal with this squeeze function and do we really need it? So let me show you what the deal is with this squeeze function, if I would get rid of this squeeze function, then this is still technically a three dimensional matrix. However, this dimension only has one element. This is called a singleton dimension. It's only one element. So now, if I would try to subtract these, this is not going to work. And the reason why this is not going to work is that we are trying to subtract a three dimensional matrix or I should say the other way, subtract a two dimensional matrix from a three dimensional matrix. And in linear algebra, that doesn't make sense. That's not a valid operation. So what we need to do is get rid of this singleton dimension so that this becomes a 1500 by 200 matrix, which you've already seen up here. OK, now it also gets a little bit confusing because some functions require this squeeze the matrix to be squeezed and some functions don't. And sometimes that's version dependent. So some versions of Matlab will crash on a line like this and some versions of Matlab won't crash. So unfortunately, it's kind of so it gets a little bit counterintuitive sometimes. OK, the point is now we have our two data sets. We have the CD, this is the full data and we have the nonferrous locked data. Now, from here on out, there's a lot of stuff that's pretty similar to everything you've seen before. So we take the safety of the data separately for the total data. And here I call it induced. Sometimes it's called induced and sometimes it's called nonferrous locked, actually typically preferred non phase locked. But it's good to know all of the various terminology. So here I'm reshaping the data from a matrix, from a time by trials matrix matrix into one single really long vector. And if you're confused about why that is, this is something I covered in the video that was called Time, Frequency, Power of multiple trial EEG data. And then here we get the baseline. Now, here we run convolution. This is also basically the same thing that you've seen before. The only difference the only addition is that this time frequency matrix is now three dimensional and the first dimension has two elements, which is total and non phase locked. So here inside this loop, you can see we are indexing the first dimension of T.F. And that is the reason why I specified a cell factor here. With, uh, curly bracket. So now we have this cell vector, so this is the spectrum of the full data. The total data and this is the inducer, the non phase locked data. Now, if you got an error on this line of code trying to run this line of code, then it's pretty likely that you have already created a variable called Data X and specify that that should be a vector or a matrix. And now you're trying to reassign it to be a cell array like this. And Matlab won't like that. So if you get an error here, then you can check your Matlab buffer, you can type who's and see if you already have a data X in there. And if so, then basically you should just clear the entire workspace and start again from the beginning of this script. All right, so let's see, loop over frequencies, create these complex Morleigh wavelet. Now here you can see some hard coding, the fool with that half maximum to be point two seconds, which is two hundred milliseconds. And that's going to be the same parameter for all of the frequencies that there's no particular reason why I did that here. It's just gone for a little bit of variety. OK, then we get the spectrum of the wavelet. Now you'll notice that in some videos I normalize the wavelets. I had complex more. That equals complex multi x divided by a mix of complex material. But here I didn't have that. And there's a reason why this is not necessary. So you kind of have this normalization here, but it turns out it doesn't matter. And the reason why it doesn't matter is that we are normalizing the data here. We're normalizing the time frequency spectrum over here. So therefore, this is one normalization and this is another normalization decibel. So you don't need to have both. Let's see. And then the main thing I want to point out in this loop here where the main part of convolution is done, is that I'm actually storing the raw power inside this T.F. Matrix and then I'm reassigning the data in that T.F. matrix. So this row, which basically means all of these time points for this frequency. So I'm reassigning those to be from the raw power to the baseline normalized power. Now, typically, I don't recommend coding like this, and the reason is that it's really easy to make a simple mistake. For example, it would be really easy to accidentally put a one here instead of the looping index. I and if you did this, then that's not good, because then you'd be using the wrong baseline. And in fact, you're going to start getting nans because this can be negative. This can contain negative numbers after it's been normalized for the first iteration. So then at the second iteration, when I equals two, you're going to have a negative number inside the log function and that's going to give you negative infinity. Anyway, so what would be a better way to do it? I think a better way to do it would be to make this be a temp variable. You call this temp power or something, and then this would be tampoe and then this would be temporary. And of course, you'd have to make sure that your indexing the correct time points in tempo, all the correct dimensionality. OK, so let's run this out, make sure that all works. OK, that looks good. Now we get to putting this up. So part of this plotting isn't super interesting. It's basically just using contour F and just specifying things in the looping index and the color limit here. You just have to play around with a few different values until you find something that looks good. So here you see the results. There's two things I want to point out explicitly. One is that computing the phase locked power is easier than you might think. So you might think you have to do something really weird and complicated. But to compute the phase like power to estimate phase, like power, you literally just subtract these two. So you say the total minus the phase locked and that gives you the phase locked power. And you can do this after decibel normalizing these two maps. So that was that thing. And then I also said in the previous video when I was introducing this project, that you should figure out a way to get the ERP to be plotted on top of this time frequency powerplant. So here's how that works. I think I already gave you a little bit of this code. So essentially what I do is start by scaling the ERP. So I scale it to a range of zero to one. That's what this line does. And then here I scale it up to go in the range of the frequencies. So that part so these two lines of code here will scale the SRP to be to go from basically the bottom frequency to the top frequency, and then in this particular case, I didn't want the ERP to expand the entire Y-axis range. So therefore I divide it by two. But if it's just divided by two, then there's going to be some you know, there's some values here that will actually go below the plot. So therefore, I added 10 as just a bit of an offset so you can try commenting on this line and running it again. And now you'll see that the ERP is much bigger. The highest point in the group goes the very top of the Y axis. The lowest point goes the very bottom of the Y axis. Now, there's nothing wrong with this. If you prefer the way that this looks, that's fine. I think this looks a little bit better. And I'm also going to get rid of this plus 10 offset just to show you what actually that doesn't look so bad, although now we get a little bit of extra whitespace here because this is going all the way down to zero, whereas the frequencies only go down to three. So here I add plus 10. And in my opinion, that looks nice, maybe it could even be plus five. All right. I think for this part it looks good. This plot, it starts to look at it. There's a bit of interference in here. Anyway, I hope you enjoyed it working on this project. If you have any questions, feel free to post them in the Q&A form.