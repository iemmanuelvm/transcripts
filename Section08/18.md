 In this video, I'm going to walk you through my solutions to Project two in Section four of this course, so that was creating a time frequency power plot of Channel 30 from this simple, easy dataset using the Filter Hilbert method. So let's get started. So loading the data specify the NICUs frequency as one half of the sampling rate. And here are the parameters for the time frequency analysis, so it's going to be 40 frequencies between five hertz and 40 hertz, and the width of the filter will be from will range from two hertz to eight hertz. And that you saw in the figure that I showed in the previous video and introduced in this project that the filters get wider and wider as the frequencies increase. Let's see, so here I call this variable long data, but that's really just reshaping the data from a time by trials matrix into one long vector. Now, it turns out you probably discovered this on your own. It turns out that if you tried to use the filter filter function on single precision data, Matlab will start complaining. So at some point you have to convert the data into double precision and you might as well do that up here so that you don't need to do it every single time. Inside the loop here, inside the loop over frequencies. OK, so here I'm initializing the output matrices, we have the time, frequency matrix, so that's just frequencies by time points. Here is the matrix that goes or that stores all of the power spectra from the filter kernels. Now, I'm hard coding this to be thousand, and I will talk in a minute about what that 2000 means. All right. So here's that big loop over frequencies. And in general, this is set. I separated this into a couple of different sections. So first, we have the section to create the filter and compute its power spectrum and then apply the filter to the data. So here I'm specifying the frequency range so you can see it's the center frequency minus the width of the frequency and then the center frequency again, plus that same width, and then the order is fixed at a factor of 20. Now notice that this factor of 20 is constant, but of course this frequency range is going to change for every frequency. And so that actually means that the order is going to be different for every frequency now because the order is different for every frequency, the length of the filter kernel will be different for every frequency. And that means if you would just take the FFE like this, with the NFTE corresponding to the number of time points in this filter kernel, then that means that the frequency resolution is going to change for each filter frequency, which means that basically you won't be able to put all these results into a matrix. Now, you could solve this a different way. You could put all of these into a cell array like this. However, this is going to make it really annoying to generate that plot, that image of the power spectrum of all of the filter kernels. So therefore, a better idea, I think a good solution is to do some zero padding so that you get the same frequency resolution for all of the filter kernels. Now, notice, and this is also important. This does not affect the order, the actual filter that gets applied. This is only about inspecting visually inspecting the power spectrum, the spectral gain function of the filter kernel. All right. So here we go. We apply the filter kernel to the data. Then I take the Hilbert transform of the Narrabeen filter data, reshape that Hilbert transform data back into a time by trials matrix. And then here I extract the power. So the power time series as the magnitude and then squared. Now, notice that this is still going to be a time by trials matrix, so when we're computing the baseline, we have to average twice. You need to take the mean over time points, that's one. And then also the mean over trials, which is dimension two. And then here I create the time frequency matrix. And that's the average of all the over all the trials at each time point divided by the baseline and then times ten log ten four decibel. Now we get down to the plotting. And this isn't so interesting, except there is something that I would like to point out about how the function, image scale works and therefore also the function image. Now very often when you're using the image scale function, you are inputting into X and Y axis coordinates an entire vector. But it turns out Matlab doesn't care about that vector. Matlab only cares about the first and last data points in that vector. So really the only thing that you need to input is two values for X and two values for Y, and that corresponds to the first value and the second value. Now I want to explain make sure I explained this well enough. So I'm going to run all of this code so we generate this plot here. So essentially, when you are specifying the x axis coordinates in the Y axis coordinates, the only thing that you really need to specify is the start point and the end point. So in this case, for the X axis, it's zero. And the Nykvist are the sampling rate, which is 256. And then here I'm specifying this to be smaller than that. And here on the Y axis, we get the frequency. So the first frequency up to the last frequency. And this will give you exactly the same result as this as inputting the entire vector. So that's also important to know, because it means that if this frequency vector is changing logarithmically, so in this case, it's changing linearly. But if this were changing logarithmically, then the X or so the Y axis coordinates here are going to be incorrect because Matlab will linearly spaced them. So if you have logarithmically increasing frequencies or logarithm, I guess I should say in general monotonically, but non-linearity increasing anything, then you cannot use the image function so easily. Like this is a way that you can do it. You would have to input an empty vector here and then matlab will just replace these with indices. So this is now not frequency. This is just indices because I've specified an empty second input and then you would have to, on your own in the set function manually specify what these values should be. I find that to be kind of annoying. So whenever I'm using nonlinear X or Y axis indices, I just use contrast and contour f all these contour functions and SIRF functions. They will deal appropriately with nonlinear spacing on the X or Y axis. All right. And then here is the time frequency powerplant.