 So following up from the previous video where you got the chance to program the Forward 48 transform from scratch in this video, you're going to have the opportunity to program the inverse Fourier transform from scratch. So what we're going to do is first compute the forward for you transform. This is actually all the same code as in the previous video. In fact, I think I'll run this first cell, run this cell. And this is really the same thing as in the previous video. Now it comes time for the inverse Fourier transform. Again, you can see that there's two key lines that are missing in this first line. What you have to do is create a template sine wave for each frequency. And then once you have that sine wave, that template sine wave, you multiply the Fourier coefficient by that sine wave and then add it back onto these reconstructed signal, which is initialized to zero. And then you can plot the original signal, you can plot the reconstructed signal, and then you can plot the Matlab, the output of Matlab inverse function of the four year coefficients that were derived from the Matlab function. OK, so I assume you've paused the video and had to go at this. So let's see, this is going to be the same concept. So we need to pi times f times. I think I call this F time. Is that right. Yeah. So this is the innards of a sine wave and then we have to embed this inside Euler's formula and that gives us E to the eye. Now, what's different about the complex sine wave in the inverse Fourier transform compared to the forward for transform is that there's no minus sign. So up here in the forward for you transfer, there's a minus sign and basically every one of these imaginary components to cancel out. So in the inverse Fourier transform, there is no minus sign. OK, now we say the recon signal equals itself, plus the template sine wave. So for Ehsaan, except now we need to modulate it according to the Fourier coefficient that we already have. So that variable is called Fourier coughs and then we want the FISA element. Multiply that by the template sine wave. All right. So now I'm going to run this cell, if you like. You can give a little drum roll, see how we do. All right. And what you see, actually, let me let me put these two first. So what do you see here is the blue line, this is the original signal and then the red dots on top of that is the reconstructed signal. And then here are also in circles. But these are black circles. That's the output of the Matlab inverse function. And you can see that that completely overlaps the red circles here. All right, so I want to make a couple of remarks about these two lines of code now. First of all, you'll notice that I'm not just plotting the reconstructed signal. I'm plotting the real part of the reconstructed signal. And in fact, if you look at this reconstructed signal, you will see that it's actually a complex signal. So it has real parts and it also has imaginary parts. Now, that might cause a little bit of concern or maybe a feeling of uneasiness, because if it's really a perfect reconstruction of the original signal, then there shouldn't be any imaginary parts, because the imaginary part, because the original signal was only real value. However, if we were to plot the imaginary part of this, I'm going to say plot image recon Sig Sanam explicitly plotting only the imaginary part. You can see that that is just a flat line. So what's really happening here is that there are tiny, tiny computer rounding errors in the 50 and 50 functions. And these kinds of functions and these tiny democratization errors are giving technically a non-zero imaginary component. But you can see here that this is really basically zero. In fact, we can try zooming in here and in turn, zoom on. Sometimes if you zoom in to, you know, like 10 to the minus 12 or 10 to the minus 16 thereabouts, you might actually start seeing a little bit of something. So now I'm at ten to the minus nine and it's still a totally flat line. Ten to the minus 10 oh, I think I see, OK, here you go. Now, when we get down to ten to the minus 14, you start seeing some random jitter here in the imaginary component. So that is around 14 to 14 or 15 orders of magnitude smaller than the signal itself. So that's basically something we can ignore. The second thing I would like to note is that I'm multiplying the output of the inverse Fourier transform by PN something ln times, and I'm not doing that here for this manual inverse for you transform. Now, the reason why that is happening is because up here I have already divided these coefficients by NT. So this was a normalization factor that I added here. So here I divide it by NT. So here I didn't need to multiply by NT.