I hope you've gone through this code and solved all of these problems.

What I'm going to do in this video is walk through the first four problems and then I'll do the other

four in the next video.

So let's see.

So the general instructions for this entire script are to simulate time series data that can be used

for testing time series analysis methods.

So let's see.

Essentially, what we want to do is build up an EEG data structure with the EEG lab format.

And I've already introduced you to this format several videos ago when I was talking about the data.

And then we use this function plotts in EEG, which will show us some different ways of visualizing

the data.

All right.

So let's start.

So here we are, starting with creating pure white noise.

So and this is really just to gain some basic familiarity with how to set up the data simulations.

So the sampling rate is 500 and the number of points is arbitrary.

Well, not totally arbitrary.

I mean, one data point is not very interesting.

And on the other hand, you know, some excessively large number of data points is going to just destroy

your computer's memory and basically not let you do anything.

So let's go for I'm going to actually specify this in seconds.

So if we want to simulate data for, let's say, two seconds, then we can write s rate times, too.

And the reasoning behind this is that there is 500 time points in one second.

That is the definition of the sampling rate.

So if we want two seconds, we can just write egressed three times two.

And the nice thing about soft coding it like this, instead of just writing, you know, one thousand

is that now if I want to change the sampling rate to five 12, I don't need to change this line as well.

OK, and then we have the number of trials and let's go for how about 30 and then the number of channels,

I don't know, let's do 10.

Here we are defining a time vector and this is already done for us.

And so you can see that there's two parts to creating this time vector.

The first part goes from zero to the total number of points, minus one.

And so this is going to give us a vector.

Let's see, I'll start running some of this code.

So let's see, this is going to give us a vector that goes from zero up to one thousand twenty three,

so one thousand twenty four points in total and we started zero.

And then the idea is that we divide by the sampling rate and that is going to convert this into a vector

of time points in milliseconds or saray seconds, actually.

So we get two seconds starting at zero.

And if you prefer this to end at two, then you could start the the time indexing here.

You could start this to go from one to two points and then divide by the sampling rate.

And then you'll see we end at exactly two seconds, although then we don't start at zero seconds, we

start at one simple point above zero.

Either way is fine, it doesn't really matter as you prefer.

So I generally prefer the time to start at zero.

OK, so that is ETG times and now we have that data and here's where we need to create the data and

we are creating this using the rand and function.

So that gives us normally distributed random numbers.

So what we need to do is just specify the size of these data.

So you might remember from a few videos ago about the data structure that these data are stored or are

organized as the number of channels.

So channels by time, by trials.

So as long as you are using the EEG lab format, this is the required organization of EEG.

That data, it's always channels by time, by trials.

OK, so let's run this time.

And then there's this other function plot.

Smeg And the way this works is that we input an EEG structure and we input a channel number that we

want to plot the data from.

And a figure.

No.

So this is going to plot the data from Channel two into figure number one.

So figure one and then we see three representations of the data.

So here you see the all the single trial data in gray and the ERP in black.

And now this is, you know, essentially a flat line plus noise.

And that's because we didn't generate any actual signal or we generated was pure random numbers.

Over here we get the static power spectrum.

This is done by taking the Fourier transform of the trial data.

And here we have a time frequency plot over all of the trials.

Now, you'll notice that it looks like the power is increasing as you go from low frequencies to higher

frequencies.

This actually just has to do with some normalization in this code.

So we will have more to say about that in the in future sections of this course.

So if you like, you're welcome to look through this function plot SIM.

It's nothing terribly interesting.

So it plots ERP here.

It plots the static power spectrum, and here it plots the time frequency analysis.

Now, the thing is that there's a lot of code that's in this file that you might not be familiar with.

So when you look through this code, it might seem weird, like what is all this stuff and this stuff?

And, you know, why are you multiplying by two and taking the mean?

So don't worry, all of the code, in fact, literally every single line of code in in this function

you will understand by the end of this course.

So for that reason, I generally do encourage you to look through these kinds of functions and make

sure you understand what they are doing.

But that said, I think it's OK at this point in the course to leave this be sort of a little bit of

a mystery.

You know, you can feel like it's a little bit of magic.

It's totally fine for now.

You will understand all this stuff throughout the course.

All right.

So that basically solves all of the code part of this first assignment.

And then we have some questions.

So what is the effect of noise amplitude on the resulting Krass?

So first of all, we need to know how to modulate the noise amplitude, and we can do that simply by

putting a multiplicative factor in front of this rand and function here.

So I can write, for example, 10 times randon and now I'm just scaling up all of these random numbers

by a factor of 10.

So the question is, what is the result on the what is the effect on the resulting grass?

So let's notice here that these data go from, you know, approximately minus two to two.

Some numbers are a bit larger.

That's not surprising.

These are normally distributed numbers.

And here the power spectrum goes from looks like so it's basically a flat line plus noise variability,

but it's around for let's call this like four times ten to the minus three.

OK, and now I'm going to run these two lines again.

And now we can see that this has increased by a factor of 10.

So it was going from minus two to plus two and now it goes from minus 20 to plus 20.

Now, that is not surprising because we multiplied the numbers by 10.

So, of course, on the plot, the y axis stretches by a factor of 10.

Now, it might be less obvious why this increased.

This value here increased by a factor of two.

So 10 to the two.

So, in fact, this increased by a factor of 100.

It was ten four to the minus three, and now it's four to the minus one or so.

I mean, it was four times ten to the minus three and now it's four times ten to the minus one.

So this increased by a much larger factor than the time domain signal increased by.

So that's an interesting thing to just sort of keep in the back of your mind and you will learn later

on why that is the case.

OK, so what is the effect of noise amplitude on the resulting graphs?

The answer is that it increases the time domain signal, as you would expect here, and it increases

the static power spectrum power values by a larger factor.

OK, here's the next question.

Do the results change if you use normally distributed noise versus uniformly distributed noise?

So this was normally distributed noise.

I'll set this back to be the default value.

And now let's make this be uniformly distributed noise using the function Rende instead of Rande.

And so generate a new plot and.

Huh.

OK, so let's see.

Well, this is not so surprising.

Now we see that we have a range going from zero to one on the single trial level.

The ERP still looks like a flat line plus noise.

Now the static power spectrum looks totally, totally different compared to the normally distributed

random numbers that we were looking at a moment ago.

So why is that the case?

In fact, it's not actually as different as you might think.

And the reason is that we have this one really, really large value at the very beginning.

And then the rest of these numbers are actually pretty small and just show you that I'm going to change

the Y axis values.

So I'm going to right.

Set get current axis y limb.

And let's set this to go from zero to let's try zero point one for starters.

So we're zooming in on the Y axis.

Let's try point O one and let's try to point O one.

And here you're starting to see that actually this looks really similar.

Remember the first time we ran this with Gaussian distributed noise?

This was the power values were around four point four times ten to the minus three.

So in fact, this is more or less a similar range of power values, as with the Gaussian distributed

noise.

So what is the deal with this first value here that's pulling up the plot?

So that is called the DC or the zero hertz component.

You are going to learn more about that in the next section.

But for now, we can just say that that is the the average value of the entire signal.

And so when the average value of the entire signal is zero or very close to zero, which it is for Gaussian

distributed noise, then the DC values are the zero hertz value is also going to be zero.

So here with uniformly distributed noise, the expected value, the average is not zero, it's actually

zero five.

So what I'm going to do now is subtract point five, which is the expected average value from the data.

Run this again and then the DC component of the zero hertz component has basically disappeared.

And now it looks a lot more like the random normally distributed random noise.

OK, so that was pretty interesting to observe.

And then here's another question.

Are the results different for different channels?

Why or why not?

Well, the answer is kind of technically, yes.

But I think the answer that we are looking for here is no.

Technically, the answer is yes.

The results are different for different channels, and that's because different channels have different

random numbers that were assigned to them.

So, for example, here we plotted.

Channel two, this plot, Channel three, and now I'm going to plot this in figure to actually maybe

I'll do it in figure three just so we get some, you know, a little bit of consistency here.

This is the primary reason why this function has this additional input option for specifying the number

of the figure.

So now we can compare we can generate two figures for Channel two and Channel three, and it just makes

it easy to compare them.

So in this case, obviously, the numbers are different, but the statistical characteristics of the

numbers are all the same.

And that's because all the channels are generated in exactly the same way.

All right.

So I'm going to say that assignment one project one is complete.

Let's go on to the second one.

So the goal of this exercise, I think I'll close these figures to make sure we have some room.

The goal of this exercise is to extend the previous exercise to pink noise.

This was this one over aph noise that has a power spectrum that has decreasing power with increasing

frequency.

So this code is actually going to be quite different from the code that we were just working with.

One example of the difference is that here we are going to create noise separately on each trial, whereas

above we created all of the noise at the same time.

And it looks like we're changing the number of channels and I think we can move all the other parameters

fixed.

So let's see, the number of channels goes down to four.

This is the key parameter of pink noise, the way that it's being generated here, and that's called

the exponential decay or eddys.

And don't worry about what this parameter means for now.

I'm going to explain this in a little bit below.

So let's see.

So we initialize the data as a Xeros matrix.

So we are going to redefine the data.

So we already have the data defined from the previous cell.

But now I'm going to initialize it to be all zeros instead of random numbers.

So this is going to be remember, it's always end by chance of the number of channels and then the number

of time points and then the number of trials or repetitions.

All right.

So run that line and what are we doing here?

So we have a loop over channels and then a loop over trials within each channel.

Now, what we are going to do here is generate the power spectrum that we want and then we are going

to take the inverse Fourier transform of that power spectrum in order to get back to the time domain.

The reason for doing this is that pink noise is very easy to define in the frequency domain.

It's also possible to define it in the time domain.

But here we are defining it in the frequency domain.

Now, just as a little warning, if some of this code looks really weird and you have no idea what this

means, again, don't worry, we are going to cover all of this stuff in the next section.

So that said, I will explain very briefly what all of this code does.

So here we are generating some random numbers.

Notice these are uniformly distributed random numbers.

These are all positive values and then are multiplying it by this funny looking function here.

So E to the minus something divided by something.

This might already be familiar as a little bit like a Gaussian.

Let's plot this and have a look.

Any time you were unsure about what some little piece of code does whenever possible, you should always

try to visualize it.

That will give you a lot of interesting and important insights into what's going on.

All right.

So this looks like well, it not looks like it is an exponential decay function.

So it's high here.

It has a large value here, and then it gets smaller and smaller here.

So let's see what happens when we multiply that by random numbers.

So now I'm going to plot A.

S, and this gives us random numbers that are all positive and they are decreasing with increasing values

of X.

And of course, this is going to be converted into frequency.

So essentially what you can see is that this is coming up with the desired spectral response of the

pink noise.

And then we are going to take the inverse Fourier transform to get back to the time domain.

And these are just random phase values that I'm attaching to make sure that these are something called

Fourier coefficients, which are complex numbers in the frequency domain.

All right.

So let's see.

I'm going to run all the code in this loop and then well, then we need to plot it.

So we need some plotting, that plotting function that was plot SIM EEG.

Then we input the EEG data.

And how about we plot from Channel one and.

And let's put this into figure one.

All right, so now we can see this is looking pretty neat.

So here we see the ERP shows nothing.

It's basically it's still just a flat line, plus some variability plus some noise.

The power spectrum, not surprisingly, looks one over half.

Of course, that's basically how we defined it.

But look at this.

This is super interesting.

You look at this time frequency, but this basically shows, you know, well, isolated bursts of activity.

Now, if you didn't know that this was simulated data, that this is fake data, we just made up these

data and you just saw a plot like this, this actually looks pretty interpretable.

You might think, oh, there's bursts of Alphabeat activity around 10 hertz.

So that is a really important concept that you get from simulating data and running analyses through

simulated data.

Essentially, when you apply some analysis method, you're always going to get some results.

Something is going to happen.

So therefore, when you're looking at real data, it's important to make sure you're doing proper statistics,

make sure you are linking the data to your experiment design because you need to know whether what you

were looking at could have arisen purely by chance in noise.

OK, so I want to let's see.

This might be one of the questions.

So which looks more OK, which looks more like real data, white noise or pink noise.

Obviously it's the pink noise.

This looks more like real data, both the static power spectrum, the dynamic power spectrum and the

single trial EEG data, which we don't really see here.

But let me show you that.

So I'm going to open up a new figure.

Let's plot IEG Times and EEG, the data about Channel five, all time points and trial for.

Oh, right, we only have four trials.

I forgot to reduce that number.

Let's go for are not trials channels.

Let's go for Channel two.

Now, if you are familiar with working with EEG data, then you will probably recognize that this looks

more like EEG data compared to pure white noise, which would just look like this.

So red and EEG that points one.

So this doesn't look like EEG data.

This looks a lot more like could be EEG data.

And if you're not familiar with looking at a lot of electrophysiology data, then you can just take

my word for it.

For now.

You will see you will gain more experience looking at real EEG data over the next several sections of

this course.

All right.

So that was the answer.

Pink noise looks more realistic.

And why is this the case?

Because real data exhibit this kind of a power spectrum.

OK, so now we have another question which values a variable.

Ed, this exponential decay make the data look most like real EEG data.

Well, we don't really need to worry so much about most.

Like, what we need to do is basically just play around with a few different extreme parameters.

So this was 50 and now I'm going to change this to five and I'm going to put this in its own figure.

So in figure two, this will be with an exponential decay parameter of five.

And then I'm going to change this to maybe one hundred and fifty.

So we'll get three ranges, one very low, one medium.

And one hopes and this needs to be in three figure three.

All right.

Well, I guess one hundred and fifty isn't really so large, but you can see what the effect of this

parameter is by looking at the shape of this static power spectrum here.

So this decays relatively slowly.

This decays really, really steeply, and this decays somewhere in the middle.

The slope is in the middle.

So if you look at these different characteristics, essentially, you know, I don't think there's any

particular value that is optimal for real data.

But it is interesting to note that when the power spectrum gets really, really steep, then it starts

looking less like real data.

And when the slope is too gentle, then it also starts just looking more like white noise.

Now I can explain very briefly what this parameter does and why it has this effect.

So here we have E to the minus something.

I'm just going to just to make this easier to look at.

I'm going to call this T minus Ed.

So now we can think about what happens as this parameter gets larger and larger and larger.

So as this parameter gets really, really big, then this fraction.

So t divided by Ed, this goes to zero because the denominator is getting really large relative to the

numerator.

So this basically Tensas is E to the zero and E to the zero is just one.

So when Ed gets really large then essentially this entire term just becomes one.

And then we are generating a power spectrum that is pure flat white noise.

So that's that's basically the answer to why this happens.

All right.

So that was pretty fun.

I'm going to call that a successful completion of the second assignment.

Let's now go on to step three here, Project three.

So here we are going to create ongoing stationary signals.

So we want to create a data set with ongoing sine waves.

And there should be multiple sine waves simultaneously in each channel and in each trial.

All right.

So looks like what we do here is come up with a list of frequencies.

We have three frequencies, three amplitudes, and these are values and Hertz and these are just arbitrary

units.

And the idea is that we want to generate a signal that contains all three of these frequencies, some

together with different amplitude.

So, again, we are looping over channels, looping over trials, and then here we even have another

loop.

So we create a sine wave.

It's initialized to zeros, and then we loop over the length of Frex.

And of course, that is this variable here.

And so it looks like what we're doing is creating this sine wave vector, which is zeros adding it to

itself.

Plus something obviously is going to go here.

And then when this finishes in this loop, then we set the data to be this sine wave.

So let's see.

So I think what we need to do here is create a sine wave for each individual frequency.

So this is going to be a sign of two PI times, time, times the frequencies for this particular loop.

So as this goes through these three different frequencies, we are going to create three different sine

wave.

And of course, we need to modulate these by the amplitude.

And that was called amps.

So amps, as I times, uh, let's see, that should be a parenthesis.

There times this.

OK, now before running all of this code, I'm just going to run this to make sure that this looks good

so we don't get any errors.

And it's already a good sign.

Let's see.

I'm going to play it big times, comma, sine wave.

And here we get a sine wave that comprises the A signal, I should say, that comprises these three

sine waves.

So this part looks good.

So here's a pretty interesting line of code.

So we can see that EEG, that data is four by a thousand by thirty.

So that's four channels, eight thousand twenty four time points and thirty channel trials.

However, this vector sine wave is just one vector with one thousand twenty four time points.

So if you actually run this line of code that's going to overwrite this data structure and we'll end

up with EEG data being just a single vector.

So this is no longer a 3D cube of data.

This is a vector.

So this is actually wrong.

This code is incorrect even though it's not producing any errors, but it's the wrong code.

So notice that we are inside this double for loop over.

Channels and trials, so in fact, this needs to be ITG data from this channel all of the time points

and this trial.

OK, so now this is better, except that the instructions here say the data as a sine wave plus noise.

So I'm going to add a bit of noise.

So and it doesn't say what kind of noise it should be.

So if the you know, if it's supposed to be white noise or pink noise or anything, but just for convenience,

I will make this be white noise.

So this is going to be the same size as the sine wave, which is a factor of time points like this.

All right.

So I think that is going to work.

Let's see if I run all of this code and we don't get any errors.

And then let's plot this and have a look.

All right.

So this is pretty interesting.

You see, the ERP looks pretty much exactly like all of the single trials.

So there's a little bit of noise, of course, that we added.

But the ERP and the single trials all look basically the same.

And that's not surprising.

There is nothing stochastic.

There is nothing random or trial unique about the way that we created this signal.

So it's not surprising that every single trial looks almost exactly the same, plus some little bit

of noise.

And you can also see comparing the magnitude here.

So the magnitude of this random noise is around one.

So it's you know, most of the random numbers are between minus one and plus one.

So over the course of let's see how many trials we have over the course of 30 trials, all those random

values are going to shrink down to their expected value of zero.

So then it's also really interesting to see the static power spectrum versus the time frequency plot

in the static power spectrum.

You see the three frequencies that we simulated.

So that was three, five and 16.

So three hertz, five hertz and 16 hertz.

But when you look at the time frequency plot, so the 16 hertz is clearly there.

You see this concentration here at 16.

But what is going on down here?

It looks like there's these individual bursts instead of what we would expect, which is a a line of

pure horizontal line with constant energy at three hertz and at five hertz.

And in fact, what you see is that there is these bursts of energy at five hertz and they are rhythmic

at three hertz.

So in this period of one second, there's one, two, three bursts.

So there is this kind of beat artifact at three hertz modulating the power at five hertz.

So this we can call a failure scenario of time frequency analysis that we know what the ground truth

was.

We simulated the data.

We know what the ground truth was.

You can see the ground truth here in the static power spectrum and you fail to identify or fail to recover

the ground truth data in the time frequency plot.

So this is already you know, we are just getting started in this course.

And you can already see a great example of the importance of generating data with known ground truth

to understand the limitations of data analysis methods.

Now, the wrong conclusion to draw here is that the static power spectrum is amazing and always perfect,

and time frequency analysis is stupid and horrible and it never works and it's wrong.

That's the wrong conclusion.

But it is important to understand why that is the case and how to go about fixing it.

And that's, of course, way beyond the scope of this particular lecture.

I'm going to talk a lot more about that later.

And by the way, just so it's clear already from the outset, you will see several other cases where

you get the opposite effect, where the time frequency result shows you the correct result.

It reveals the ground truth and the static power spectrum becomes very difficult to interpret or sometimes

basically impossible to interpret.

All right.

So that was super interesting.

Let's see what questions we should answer here.

What can you change in the code above to make the EEG activity non fais locked over trials?

Interesting.

So to get this activity to be nonferrous locked, what we need to do is randomize the phases.

So here is our equation sine two pi F.T. and then we need to add plus theta.

So plus a phase value and this needs to be a random phase value.

And I mentioned in the video in the slides a few video.

Years ago, how to transform a uniform, distribute distribution of noise to appropriate face value.

So we need to multiply this by two times by now.

Notice that this is going to be different every time this particular, uh, function is called.

So let's see how that changes the plot and then let's put this in plot three.

All right.

So then we do this.

And so this is pretty interesting, looking back at which figure was it?

Yeah, I think figure a close figure one.

So here was with the purely phase lock signal and here was with the purely non phase lock signal.

So comparing them you can see the effect on the ERP is huge.

We went from having this perfect ERP to having an ERP that kind of looks like a flat line with just

some, you know, random variations on top.

But when you look at these static power spectrum, that looks it's basically identical.

The Y axis is a bit different here.

I'm going to set the Y axis limits to go from zero to twenty five.

So it matches this.

But now you can see those are exactly the same.

And then at the time frequency plot, we see something kind of similar.

So at 16 hertz we still see this.

And now this beat artifact has gone away.

In fact, that beat artifact is still there at the single trial level.

But the beats have different timing on different trials.

So those get all averaged out, just get kind of smoothed out at the single trial level.

So that is just to make sure that this is clear.

What's happening over here with the non phase locked activity is that the timing of these beats is actually

slightly different on each trial.

And so therefore, when you average over 30 trials, all of those beats kind of merge together into

this one smoother function here.

All right.

So let's see.

That was one question.

And then here's another question.

Which of the plots look different for phase locked versus non phase?

OK, so I already actually answered that question.

If you are surprised about the differences, then that's great, because it means that you can be really

excited about the rest of the course when you will learn exactly why these differences occur.

OK, and then we have another question.

Are all frequencies equally well represented in these static and dynamic power spectra?

And can you change the parameters to make these spectral plots look more or less visible, more or less

similar in the two plots?

So they're the answer is that in the static power spectrum, the all three of these sideways look perfect.

They're perfectly represented.

And in the time frequency plot, the answer was no.

Sixteen hertz looks good, but five and three hertz got merged together.

So one thing we can change to increase the visibility is to separate these frequencies a bit.

So let's go three, 10 and 16 and let's see how that resulting plot looks.

OK, so now you see a little bit better.

There's still some interesting interactions happening between the 10 hertz and 16 Hertz activity.

But here you also see the three Hertz activity popping up.

All right.

Let's see.

So this was really good.

So now we've gone through the first three exercises in this problem set.

And I actually said that I was going to do four.

But I see now that this recording is going on for quite a while.

So I think I will stop the video here and then I will continue with number four in the next video.