 In this video, we are going to explore this issue of the key parameter of Morleigh wavelets and how that constrains this trade off between temporal precision and frequency precision. We are going to start off with some code that will just simulate a bunch of Morleigh wavelets. You can see we are going to use four different cycles, so two, six, eight and 15 at eight hertz. And essentially we're just going to plot them in the time domain and then compute the power spectrum and plot the amplitude spectrum in the frequency domain. Essentially, this is just reproducing a figure that I showed in the slide in the previous slide. But the reason why I wanted to have this in code for you is to give you the opportunity to explore the effects of different number of cycles and how that also interacts with the frequency. OK, so let's see. All of this code, I think is fine. It all looks good. And now here we are looping over. So we need to create the width here. So remember, this is not just the number of cycles. So this is not just some cycles and then the ith element. We also need to normalize. And you'll recall from the previous video that the normalization factor is that we divide by two times PI times the frequency, which I think was called FRAXA times, the frequency of the sine wave that creates the wavelet. So here we are creating. So here you can see that s parameter in the equation here. So here we are computing not the Gaussian or sorry, not the wavelet is what I meant to say. But instead we are just creating or just plotting the Gaussian that creates the wavelet. So let's see, I'm going to start running some of this code to make sure that all works before I run all of the code. All right. So here you see a Gaussian with two cycles and let's see what this looks like in the frequency domain. So we have an extra square bracket here. I'm not sure what that's doing there. So let's see the complex. Morleigh Wavelet is the sine wave complex in Mazar E to the I to PI, F.T. That part looks right. And then times the Gaussian, which is E to the minus T squared over two S squared. So that part also looks right here. We take its FFT and we normalize it. And now because we're not actually running convolution, we don't really even need to worry about the end of the field. We can just use the default value, which is going to be the same length as the input signal. OK, and then we are plotting the magnitude and that you see here. OK, so this looks fine. So I'll just run the rest of this code here. So again, as I mentioned, this just reproduces one of the figures that I showed in the slides a few moments ago. And basically what I encourage you to do is play around with these two numbers, these two lines of code to see how that is going to affect the resulting plots in the time domain and in the frequency domain. I guess one one other thing to note here is that if you are changing the frequency to be higher than, you know, maybe like 15 hertz or so, you might need to adjust this x axis limit as well, because this is hard coded to go up to 20 hertz. All right. So now what I want to do in this code here in this cell is basically something similar. So we are going to use different wavelets with different numbers of cycles and we are going to apply them to different R to the same data. And then we will explore what effect these different numbers of cycles has on these same data set. So let's see. So we load him EEG data. We are going to extract frequencies from two hertz to 40 hertz sorry, two words to 30 hertz in 40 steps. And then we're going to plot data from Channel One. This is in the back of the head over visual cortex. Let's see. So here is a time window that's used for baseline normalization. Now, I haven't yet talked about baseline normalization, so for now, you don't need to worry too much about understanding what this means. This is time in milliseconds relative to the time zero the stimulus onset. So essentially what we're going to be doing is normalizing the time frequency powerplants. For now, all you need to worry about is the fact that this is going to help us visually interpret the results over different frequencies, which will allow us to better inspect the effects of this number of cycles parameter. And over the next several videos, I will be talking more. About this baseline normalization. OK, so let's see here we define our frequency's time vector for the wavelet and then we get to some of these parameters. So the the end of the wavelet of the kernel and of the data, you can see its points times trials. So we are going to be doing the time frequency decomposition for all of the trials. And then we have the end of convolution, which is the all important formula, which I know you have memorized, and plus minus one. All right. And then here you see we have our output, our results matrix is going to be stored in a 3D matrix where we have frequency's by time. So there's going to be a time frequency data for each of the different numbers of cycles. OK, let's see. So here we take the spectrum of the data. And as you already know, of course, this can happen. This can be computed outside the loop over frequencies because the 50 of the data does not change with different frequencies. OK, and then let's see what's happening inside here. So here's a loop over the number of cycles, parameters, and then we loop over frequencies. So we define the S parameter here. That's the number of cycles divided by two PI F four F is the frequency of the sine wave. Let's see here we create the wavelet that looks good. This looks legit. OK, I think this is all fine here. We do convolution you know, I write all of this code and then I take parts out of it to give you a bit of a challenge. But then by the time I'm going through and creating this video, I often forget or not often I always forget exactly what I've done in here. OK, but all of this code or that is I forget, you know, which parts of the code I've taken out and change how it's it's as exciting for me as it is for you, basically. OK, so all of this code you have seen before, the only piece of code that is new is this line here which computes the decibel normalization. And essentially what I'm doing is dividing the time frequency power data by the time frequency power data averaged from a baseline time window, which I mentioned earlier. Now, again, I want you to just ignore this. Just accept that this line is here. I'm going to have several very I think it's two whole videos, basically just talking about this line of of code here. So for now, we're just going to ignore it. So I'm going to run all of this code in this double for loop, and it all runs pretty quickly. And here we are just doing plotting. So let's see if this is all going to work. All right. Very nice. So here you see exactly the same data, almost exactly the same wavelets. So all the same frequencies. And all I've changed is the number of cycles. So it's two cycles, six, eight and 15. And it's interesting. It's quite a remarkable difference. So when you look at these are kind of two extreme values. So we have two cycles and 15 cycles. That's that's kind of at two ends of the extreme. I would say two cycles is definitely too few for almost any time. Frequency analysis. There might be some exceptional case where two cycles make sense, but by and large, two cycles is generally too small. 15 cycles is an OK number for higher frequencies. It's a bit too too high. A bit too wide of a Gaussian for wavelet for these lower frequencies. And you can see that six and eight. So qualitatively, basically the same patterns. Of course, they're not identical. Whenever you change something in the analysis parameters, that's going to change something in the results. But these two look like a pretty good range, finds a nice trade off, a nice balance between temporal precision and spectral precision. All right. So now what I want to do so I mentioned in the video that what's common in the literature and generally a good idea is to change the number of cycles as a function of frequency. So what I'm going to do now is create a new time frequency plot where the number of cycles is different for each frequency. We start off with four cycles at the lowest frequency. So three hertz or whatever was the lowest frequency. Maybe it's two hertz and then we get up to 13 cycles at 30 hertz. So here I define the range and here I define the number of cycles for each frequency. So let's see what these look like. So here you see the number of cycles is changing. And you can also see that these are not integer values. The number of cycles is changing and we can. A plot of this, I'm going to plot Frex by and cycles and let's make it squares with a line on it. So here you see I'll put in some labels. X label is frequency and the Y label is the number of cycles. So as the frequency increases, the number of cycles is also increasing. And this is a monotonic but non-linear relationship. This is a long relationship. And to get this long relationship, I'm using this function log space. So it may look a little weird that we have lugg space and then log 10. I want to take a brief tangent here to tell you a little bit about this log space function. So you already know about the linearly the Lin space function that generates linearly spaced numbers between, for example, one and two or in general between the first input and the second input and the number of steps corresponding to the third input. So here we get six linearly spaced numbers between one and two. Now, if you want logarithmically space numbers between one and two, you might think that it would be as easy as saying log space one comma to come six. However, this gives results that might look initially a little strange because we specified or, you know, we tried to specify log space numbers from one to two and we got 10 to 100. But in fact, if you look at these numbers, these two boundaries, you might recognize that this is ten to the ten and this is ten or so. Ten to the one and this is ten to the two. So in fact, when you use the log space function, Matlab interprets this as being the exponent for a base ten. So if you want to get logarithmically spaced numbers between one and two, you actually need to input the log base 10 of one and the log base ten of two. And that gives the expected result. And so what you see here is that the distance between, for example, the first two numbers is smaller than the distance between these last two numbers. So these are point zero, point one five apart from each other, and these are point to five apart from each other. So that's what you see here. The distance between successive points is getting larger with increasing frequency. Now, I'm going to have a whole video later on in this section about whether to use linearly spaced or log spaced frequencies. But the short answer is that it doesn't really matter. Mostly I'm using log space just to introduce you to this function. All right. So with that as a tangent finished, let's now so let's see. So we initialize the time frequency matrix to be frequency's by points and here we loop over frequencies, so we create the wavelet. So this is the number of cycles divided by two pi f here we create the complex Morleigh wavelet and that looks pretty accurate here. We compute the FFE of the complex Morleigh wavelet and I see a mistake. I hope you called it as well. In fact, this is let me set this to be one. Now if you would do this. So it's funny that Matlab is already giving us a strange warning. It says FFE length must be a non-negative integer scalar. A scalar just means a single number. So what we actually you know, the problem here is that we are taking the FFE of this single number and then the end of the FFE is this whole vector. So I don't even know. Yeah, OK, so matlab doesn't even do anything, it just returns empty. It's not really able to compute. All right. So let's see. We need to just turn around these inputs. This looks pretty good. And let's have a quick look at this. I'm going to plot ABSs complex, Marlay Wavelet X and what we expect to see is a Gaussian and the positive spectrum and nothing on the negative side of the spectrum. And that is indeed what we see here. So that looks good. Some quick visual confirmation. Of course, these are frequency indices, not frequencies in Hertz. OK, so run convolution. And to do that, we take the inverse FFE of the element Y's or frequency Y's multiplication of the data by the wavelet. So the wavelet is CMW X and then the data. What did I call that variable Sigma Theta X. OK, so it's the Times Data X and now I. And ask a question here that I would like you to answer, the question is, do we need to specify explicitly in the IFP function that we want the number of points in the inverse Fourier transform to be in control? The answer here is no. We do not need to mention this explicitly. And the reason is that by default, the effective function will use the NT for the F.T. to be the number of points in the input and the number of points. The input is already in control. So if you like, if it makes you feel happy and comfortable and warm and safe, you can leave this parameter in here as a second input. But it is not necessary. OK, let's see. So then we klym clip the wings of convolution here and then reshape back to time by trial. So that all looks legit. We get back a matrix of time by trials and then we extract the power and average over the second dimension, which is trials. OK, so this all looks good. So I'm going to run this for all frequencies. You can see it's very fast. Convolution is very fast. Here again is this DB normalization business, which we are going to ignore for now, and we will talk much more about it in the future. Hmm. Now, this is funny. We did convolution and I think everything worked fine here, but the plot is all red. All we see is red. So let's see if we can figure out what's going on. It could be there's basically two possibilities. One possibility is that there's something wrong with our code. So something wrong with the with the math, with the analysis. Another possibility is that this is just a weird plotting issue. So to distinguish between these two possibilities, what I'm going to do is run this line of code without setting the color limit. OK, so here we see we get a result. It's kind of hard to see. It's all faded or it's washed out. Basically, the color is going towards all of these low, very high power regions down here. And so I'm actually also a little bit surprised. Maybe I did I forget to run this line of code. So it turns out that we didn't I didn't actually make any mistakes, there's nothing wrong with this code, but we are missing something. And what we are missing is the normalization of the wavelet in the frequency domain. So I'm going to add complex Marlay Wavelet X equals itself, divided by the maximum of complex multi wave X like this. All right. Now, let's try this again, and I will run all of this code. I hope that you caught that as well. Let's see now. Let's have a look. So this was actually correct how it was before. It's just that the color scaling was totally off. So now this actually is in reasonable units. And then down here, I'm just plotting the the decibel normalized version of this. So these come from the same data. This is normalized. This is not normalized. I'm going to talk more in a few videos about how this normalization works, why it's the right thing to do and how to pick the baseline period for normalization. But nonetheless, the main point of this video was to explore the key parameter of wavelet convolution, which is the number of cycles. And I think the important conclusion is that in practice, when you're really sitting down to do these analyses, it's often good to have a range of cycles. So you start from a low number of cycles and move to a higher number of cycles with increasing frequency.