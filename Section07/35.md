In this video, we are going to explore different ways of scaling frequencies, either linear scaling

or logarithmic scaling.

And so what we're trying to do is basically construct two plots.

One is going to be with linearly spaced frequencies and with log spaced frequencies.

And you will see that it's in my opinion, this is mostly a matter of personal preference.

So I'll give a few recommendations at the end of the video.

All right.

So let's load in the data set.

We specify the frequency range to go from ten to one hundred and we are going from ten to one hundred

in one step.

So that is not really useful.

How about we go 60 steps?

So let's see.

And then basically here we're going to set up the code to work for either linearly spaced or logarithmically

space, depending on how this parameter is defined.

So here's how we toggle that.

So we say if log only in this variable and now this is kind of interesting.

So we say if the second element is equal to zero, then we define the frequencies to be logs based of

log 10 of the first element in Frech range to log 10 of the second element, in fact range else.

So if the second element is not equal to O the string, the character letter O, then we do linearly

spaced from free range one to frequency two.

So I have discussed in a previous video why when you're using the log spaced function, you need to

write log 10.

And if you missed that video, then I will leave it up to you to figure out.

But the short version of the story is to think about what happens when you write log space from one

to two in four steps and you end up getting ten to one hundred, which is actually ten to the power

of one, going up to ten to the power of two in four steps.

OK, so that is the short answer to why we need to scale these numbers back down using log ten.

So and the reason why I test only the second element is because the first element is going to be L,

regardless of what we specify.

So that's not indicative.

That's not discriminative.

The second letter is the first letter in this string, in this parameter that's going to tell us whether

the user, which is us, you know, you specified linear or log and then whatever else comes after,

it doesn't really matter.

All right.

So let's run this.

So we're going to start with linearly spaced frequencies.

So then we set up the convolution parameters, let's say, OK, so this looks fine.

This looks fine.

This looks good.

And can we need and data plus and Kurn minus one and then all of the rest of this stuff looks fine.

OK, then we create the wavelets so initialize and here we have the time domain wavelet which is defined

as the square root of hello times the Gaussian.

I don't think this is really correct.

It's not the square root of hello.

It is actually a complex valued sine wave.

So E to the I and then K where K is the innards of the sine wave, which is two pi times frequency.

I guess it's called Frex this variable.

Uh yeah.

Frex Frex F.I. Times and then we have time.

There you go.

That looks better.

And then you might remember in the previous video I had a little trick here, I said this to be Min

instead of Max, so it was pretty sneaky there.

All right.

And then initialize the time frequency output matrix to be frequency's by points.

So let's run that.

And we haven't yet defined points.

So let's see.

We have two options here.

One option is to define a variable called points or a second option is to just replace us with, for

example, the length of time VEC or the size of the CSD matrix.

And usually the general rule encoding is if you're using a variable more than once, then it does make

sense to create a variable instead of just calling a function.

However, we're only using and the rest of this code, we're only using this variable once, so it doesn't

really save us a whole lot of time.

So I'm going to just say length of time back so you can imagine if you needed the length of the number

of time points, let's say, six times throughout the code, then it definitely makes sense to create

a separate variable rather than having to call this function each time.

But it's only once, so I will just leave it like that.

So let's see.

Uh, we take the Fourier spectrum of the data vectorized from Channel seven, all time points, all

trials.

And then I just want to, like, really confirm that this really is OK.

It really is the right size time points by trials.

So then we have to do so here.

We take the inverse for you transform.

And so inside this loop over frequencies, which is actually doing a convolution, the wavelet times

the data and then the inverse for you transform and the end of the fifty is point five, totally, totally

wrong.

I don't know who wrote this code and what kind of an awful sense of humor he has.

I'm actually just curious if this is even going to run.

OK, so it kind of runs it didn't give a full error per say, but it did give a warning and this ended

up being zero.

So, uh, so we can specify this to be and confirm, however, that is already and conv is already the

length of these spectra.

So in fact, we don't technically need that, although you could leave it in there if you find it to

be comforting.

So let's see.

Then we cut off the length, uh, cut off the wings.

We trim the wings off the two sides of the result of convolution and reshape back to time by trials.

And then we take power.

And I see another thing that we need to fix.

So this is this code here is correct.

This will extract the power from all of the time points and all the trials.

But we're not saving all of the time and trial data.

We are just saving the trial data.

So we need to actually average.

And the average is the second dimension of this matrix, which is two hundred, which is trials.

All right.

So let's run all of this code here and then we do our visualization.

So this is another little toggle here and this is basically figuring out which figure this should be

drawn into.

So figure seventeen or figure eighteen.

And then let's see, this might be all ready to go.

OK, cool.

So this was linear spaced frequency scaling and you see that it's linearly spaced frequencies because

each tick is the same distance.

So we're always going in steps of ten units of frequencies.

So let's change this now to log space.

And so this is going to say log, although technically it doesn't really matter what the third letter

is.

I don't even need a third letter.

We just need a second letter to be, oh, so let's run this again.

And then just to show you what this Frex variable looks like and actually maybe I'll plot this type

plot Frex and then like this.

So what you see is that the space between the frequencies is getting larger with higher indices, with

higher frequencies.

And let me contrast that with linearly spaced.

So I will do run this line and then hold on and then plot again.

So here you see linearly spaced frequencies and log spaced frequencies.

They start and end at the same frequency, of course, because the frequency range is the same, but

the spacing in between them is different.

So we start off with with tighter spacing and then it gets wider as we get towards the top.

OK, so now I have to run this again and we can actually run all of this code all the way down here

to the bottom.

All right.

So this is low frequency scaling.

This is log frequency scaling.

Like I'm missing an eye in there.

Let's pretend that that was intentional.

And I just wanted to check to make sure that you are really checking all the spelling.

OK, that's probably not true.

I think that was an innocent mistake that I just was typing that too fast.

Hmm.

But this is a little curious because I said over here that we get these, uh, frequency or Y-axis text

to all have the same number of units on a linear scale.

But here they're also going up in increments of ten.

And so when we compare these two plots, you see they are slightly different.

They look a little bit different.

Of course, qualitatively, they are the same.

But you might be a little bit surprised.

And the reason so here's the question.

Is there a difference in the Y axis scale?

And the answer is no.

And that has to do with how the contour function works.

So the control function is going to look at the frequencies that you have specified in the second input

or in general the y axis labels that you've specified and and try to scale the entire graph accordingly.

So what we need to do actually is change the y the Y tick label.

So.

The y axis scale, yeah, that's what we want to do.

So this is actually empty.

We are saying set get current axis and the Y scale.

That's the thing we want to change.

But now it's set to be empty.

So how do we know which one we want to set it to?

Well, so first of all, it says the value can use one of these two values.

So in fact, this error message was actually even more helpful than I was anticipating.

So thanks, Matlab.

So but when I wanted to show you is that if you are setting a property, if you know the property name

like this, but you don't know, what are the possibilities for setting the value of that property,

you can just type it like this.

Now this might look incomplete because we have set get current access and then we are, you know, we

should be specifying these in pairs.

We have the value property pair here.

We are only specifying the value and not the property.

But when we do this, Matlab is actually returning the possible answers, the possible values that we

can write for this property so we can do Linnear or Lugg now I can do linnear just to show you that

that's not going to change anything because it already is linearly scaled.

So let's do a log and now that looks different.

And now you'll also notice that the frequencies on the Y-axis are different.

So now this is also in units of powers of 10.

So it just goes ten to the one to ten to the two.

So therefore, I'm also going to manually specify that we should have frequencies from one schipp five.

So, yeah, basically every five frequencies.

And then here I'm rounding it to two significant digits.

And the reason why I'm doing that, I'll just get rid of this just to show you what that would look

like otherwise.

It just starts to get a little bit crowded, to be honest.

Two significant digits is also probably a little bit excessive because, you know, some smoothing and

things like that.

This is also probably fine.

OK, but now you see, for example, the first tick got gap goes from ten to twelve point two.

So this is a spacing of two hertz.

And then at the top here we have a spacing of 15 hertz.

So this is now definitely log spaced frequencies.

So it's interesting to go back and forth between these two.

In this case, it doesn't really make much of a difference.

But I would like to say something, General, about when you might prefer log space frequencies or log

space frequency scaling versus linear frequency scaling.

Now, if you look through the literature, you might find that some people have very strong opinions

about whether plots should be shown in log space or linearly spaced.

I actually do not have such a strong opinion because I think all the data are here anyway.

It's really just a matter of what seems more visible and what is a better way to visualize the frequency

ranges that you are highlighting in the data.

So in my opinion, if you are highlighting the higher frequencies in the data, like what you know,

sort of done here, we're looking at Gamma, we have some gamma responses.

So far, higher frequency activity, a linear scale is pretty useful.

And for lower frequency activity, if you want to highlight the low frequency activity, let's say theta,

which is actually cut off here, and alpha beta, these lower frequencies, then a log spaced scale

is preferred.

So that is generally my sort of loose advice, but I think it's really just a matter of personal preference.

Whether you prefer linearly space scales or log space scales, I think they're both fine.