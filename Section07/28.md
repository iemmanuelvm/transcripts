Let's talk about the short time Fast Fourier transform, what I'm going to do here is create a signal.

This is a chirp signal, it's a frequency sliding signal, a signal that changes its spectral characteristics,

changes its frequency over time.

This follows the formula that I showed in the very beginning of the course about simulating different

kinds of signals.

So I'm just going to start by running all this code and then let's see what it looks like in the time

domain.

So it's kind of hard to see exactly what's going on.

I hope you can see that it's a sine wave.

It starts off slow.

It gets faster here and then it gets slightly slower here, but not quite as slow as here.

So the frequency starts off low, it increases and then it decreases a little bit.

So what I'm going to do here is use the Matlab function spectrogram.

And essentially we input a couple of parameters.

We input the signal and then we input a windowing function.

So I'm using a hand window, which looks a little bit like a Gaussian.

Actually, I can show you what this looks like.

This is let's see what one.

So the huhn window looks like this and it's two hundred points on.

And then to be honest, I kind of forget what these other parameters are for.

So let's see.

So the data, the signal and then window.

Let me close this thing.

And then we have an overlap.

It looks like this parameter is, you know, if you look at this, if you scan it too quickly, it looks

like it says no overlap, but there's only one.

Oh, so it's an overlap.

This is the number of points to overlap for each successive time window.

So remember, I talked about that before in the in the previous video.

So how much overlap is there from one segment to the next segment?

And because each segment is going to be two hundred points long and I'm specifying that the number of

overlapping points should be one hundred and fifty, then we have an overlap of in this case, seventy

five percent.

So that was the third input.

And then let's see, the next one is the NFTE.

So basically Matlab is allowing you to specify the end of the FFE and of course by default that's going

to be two hundred.

So it would be the length of the data segment, but I'm specifying that it's going to be 500.

So in fact, we're doing a bit of zero padding, which is just going to smooth out the plot a bit.

And then here we input the sampling rates.

OK, and then this gives us back the time vector because it's not computing the spectrum at every single

time point.

Right.

So we've gone from six thousand time points.

The signal is six thousand time points long and from the result of the short time for a transform as

Matlab implements it here in the spectrogram function, we only get one hundred and seventeen points

back.

So we have like one sixtieth of the number of points and then we have frequencies.

There's two hundred and fifty six, two hundred fifty one frequencies.

And here you see what are the frequencies that matlab is computing this is based on.

So the frequencies that you get are based on the end of the 50 and the sampling rate.

And then we get this matrix power spectrum, which is the Fourier coefficients that each time frequency

tile.

OK, so let's see.

So let's actually let me run this again.

So here we see the signal and here you see the time frequency part of this signal of this chirp computed

via the short time 48 transform.

So you see that over time, the sine wave starts off slow, it gets faster, and then it gets a little

bit slower again.

In fact, I think the way I created this was a Gaussian plus a linear slope.

Let me see.

Yeah.

So I specify here the frequency modulator should be E to the minus T squared and then plus linearly

spaced numbers from zero to 10.

So you can see the Gaussian and then it's this linear increase over time.

All right.

So that is with the spectrogram function.

So what I want to do is now show you a simplified version of the short time for a transform so that

you see the mechanics.

So here making a new figure.

And so what I'm doing in this loop here is cutting out a snippet of data.

So data snip that's cutting out part of the signal and that is five points long.

So we cut out a little piece of the of the total signal that is 500 points long.

And then I take the power spectrum of that snippet.

So that's going to be abs of FFT data snip and then squared and then into this time frequency matrix.

I'm saying at this time point and these frequencies we take the power spectrum that was just computed

right here and then this is just calculating the center time point.

So let's run all of this code.

Here and make a plot of this.

So not bad, you can see it's like, you know, it's a little bit and it's a little depressing next

to this.

This looks really beautiful and sunny.

This looks this just looks really bright and glowing and happy and vibrant.

And this looks a little bit depressing.

Now, there's nothing wrong with this method.

In fact, you can see that the results are are more or less the same.

It's just a kind of lower resolution version.

Oh, and interestingly, I actually now see I didn't notice this before, but I now see that the time

vector is wrong here.

And that's because the time vector that is returned by spectrogram, of course, the spectrogram function

doesn't know what the original time vector is.

It just recompute at a time vector, assuming that we start at zero, but so you can ignore that part

for now.

Otherwise you see that, that my version down here, this kind of simplified manual version gives us

basically the same result.

The key difference is this has more a higher temporal resolution and it's smoother because of zero padding

in the effort.

But otherwise, you know, the fundamental results are the same.

So if you like, if you are curious, you can try to adapt this code that you see here to make this

graph have higher resolution.

So it looks a bit smoother.

It looks a little bit more like this nonetheless.

My main goal for this video was to illustrate the mechanisms of the short time for you to transform

the basic mechanisms in code to help make what I described in the previous video be more concrete.

And I hope you agree that I was successful at that goal.

The next video is going to be super interesting.

I'm going to tell you about the differences between Wavelet Convolution Filter Helbert and Short Time

for a transform.

So don't skip the next video.

I will see you then.