The goal of this video is to see in action the concepts that you learned about in the previous theoretical

video.

So in particular, we are going to start by filtering some data.

We're going to create a filter and then apply the filter to some noise.

And then we will explore the Hilbert transform and see what we can do with the Hilbert transform of

filtered data.

So let us begin.

What we are going to do is set up the parameters of the spectral shape of the wavelets.

And this is that six point sequence that I described in the video.

So we set up a sampling rate and the Nyquist frequency and F range is for frequency range.

So we are going to design a filter that filters from 20 hertz to twenty five hurt.

So bad pass filter.

Here is the transition width.

So this is in proportion.

So that means the transition width is going to be 10 percent.

And this order, this is the order parameter of the filter.

So it's the number of time points in the filter.

Now, there's no real way to know exactly what the order should be.

Furthermore, with FBAR filters, higher filter orders no longer filter.

Kernels are generally better, although when you get to an extreme, they end up not being better and

they just end up adding a lot of computation time.

But in general, higher orders are a little bit better when I'm showing here is a formula for calculating

or approximating the minimum useful order.

And the way that I'm defining that is to say, well, we should have in the filter kernel three times

the number of cycles that it takes to get over three times the number of time points it takes to get

the number of cycles of the lower bound of the frequency.

So how many time points do we need to get?

Three, three cycles at 20 hertz.

Now, to be clear, this is not a magic number, three cycles.

That's just an approximation to say that that is a reasonable lower bound for the order of the filter.

OK, so then here I define the shape of the filter.

So this is actually specifying the gain values.

I remember from the previous video that the first one corresponds to D.C. and the last one corresponds

to at.

So this is DC, this is the the lower end of the transition.

And then here are the two upper ends where the filter will pass through the frequencies that we want.

So this is going to correspond to the gain at twenty hertz, the gain at twenty five hertz and then

the transition on the right side.

So on a higher frequency from the upper bound and then Nykvist.

And here's where I specify the actual frequencies.

So it looks like a really long line of code, but it's actually just because these variable names are

a little bit long.

So notice what is going on here.

So we have X, I think I'll run this and then we can see.

So the frequencies vector here, there's also going to be six numbers that corresponds to these numbers

here for the game.

So we have Zero and Nyquist and then the second number is eighteen, which corresponds to 10 percent

of twenty or 10 percent below 20.

And then we have 20 and twenty five and then twenty seven point five, which is 10 percent up from twenty

five.

And then and then Nykvist.

And then all of this gets divided by Nykvist.

And the reason why we divide by Nykvist is that the Matlab filter colonel construction algorithm will

be expecting these frequency values to be normalized to the Nyquist frequency like this.

OK, so then we use this function FBAR less so this is FBAR for an FIA filter.

The LS is four least squares.

That's part of the algorithm that, uh, Matlab is going to use to figure out what is the best kernel.

So we input the order, the frequencies vector and the shape which is the the vector of gain values.

So now we want to look at this thing.

So here we're going to plot it's already skipped on it.

So there's some stuff to fill in here.

Of course, this is taking the power spectrum of the filter kernel.

But first, I want to see what this filter kernel looks like in the time domain.

OK, so here's how it looks in the time domain.

It looks like a wavelet that's really, really wide.

Actually, it looks like it doesn't quite taper down to zero and it's already going to give us a hint

for what we might happen to see in a few moments.

OK, so compute the power spectrum of the filter kernel.

Let's see.

So I'm going to say a.

Yes, F.T. Filt Kurn, and I don't know if we need the power spectrum or the amplitude spectrum, but

let's let's go with the power spectrum, because that's what it says here.

OK, so then then we get an air from space.

So let's see, this is the Hertz vector.

What are we trying to do here?

Well, we are actually trying to do is come up with a hertz vector, define a vector of frequencies

for the power spectrum of this filter kernel.

So we want to go linearly space numbers from zero to Nykvist, not to the filter col zero to Nykvist.

And we even have a variable for this.

And how many steps do we want?

So this is obviously wrong.

How many steps between Zero and Nykvist?

Well, it's an over two plus one and N here corresponds to the length of filt power.

So let's do floor.

So we need length.

Filt power divided by two plus one.

OK, and then here we clip the power value.

So we're looking only at the positive frequencies here.

All right.

So we already did this plotting.

So now we do the amplitude spectrum of the filter kernel so that you see here, it's kind of hard to

look at.

So let's make the plot look nicer.

And OK, so here we go and let's see what this is over here.

OK, so this is actually just the same, but in lugg space.

So here.

So what I'm plotting here is the same power spectrum that you see here in black.

But this is with, um, log space y axis instead of linearly spaced y axis.

The only reason why I show this is because sometimes, like in textbooks or in online videos or elsewhere,

you might see people show the filter Colonel frequency response in log units that allows you to see

the subtleties of the attenuation at other frequencies, which are difficult to see here.

All right.

So let's skip to the question.

Is this a good filter?

The answer is yes, if there is a good match between the ideal and the actual spectral response.

So the ideal spectral response is in red here and the actual response to the actual power spectrum of

the filter kernel that we obtain is in black.

So is this a good filter?

Uh, well, you know, is it horrible?

Is it really, really terrible?

I it's not really, really horribly awful, but it's also not very good.

Let's keep reading.

One important parameter is the order, the number of points in the kernel based on your extensive,

impressive, amazing expert knowledge of the Fourier transform.

So this parameter, the order parameter of the filter be increased or decreased to get a better filter

kernel first answer and then try it.

OK, so essentially what we want to do here is come up with a way to get a better filter kernel.

We want to improve the quality of this filter, Colonel.

Now, as I mentioned in the previous video, there are several parameters here that we could play with.

There's the transition with there's the bandwidth of the filter.

But of course, given the question and also given that I made such a big deal of talking about the order,

I think what we should try is increasing the order.

So I don't actually know what the right answer is, but I'm just going to guess 10.

So now the order is one hundred and fifty four and it was one hundred and fifty four and now it's 512.

So let us try rerunning and actually I'll put this in figure twenty one.

So let's see.

Uh so reroutes.

I reran that.

Uh let's see.

So I'm just going to make every remake the whole figure and let's have a look.

OK, now this is quite a difference, quite a spectacular difference here.

We got this terrible filter and here we get a filter that I would say looks really good.

It's not perfect.

Perhaps, you know, you could play with this a little bit and try to get it to match closer.

But on the other hand, there is a risk of trying to get the actual filter to be too close to the ideal

filter so they don't need to match perfectly and there in general never going to match perfectly.

So I would say this is pretty good.

I am quite satisfied with this filter.

And here's what you you see what the filter kernel looks like in the time domain.

OK, so let's stick with this.

So now what we're going to do is create random noise.

So I'm creating four seconds of random noise.

It's Galson distributed noise and it's four seconds because I'm multiplying the sampling rate, which

is the number of points in one second by four.

And then I'm applying the filter to the signal and this is using the Matlab function filter felt.

Now the filter filter function is contained in the signal processing toolbox, which does not come with

the default matlab package.

It's an additional toolbox.

If you have the signal processing toolbox, then you can use this filled filter function.

And it's pretty simple to use you input first the filter kernel and then the number one.

This would be different if you're using an F sorry, an AI filter for an F I r filter, you only input

a one as the second input and then the signal that you want to apply this filter to as the third input.

Now I'm not going to get into the details of how the filter function works or why this second input

is a one for fire filters and something different for IIR filters.

I talk about that more in other courses like a signal processing course, but essentially this applies

the filter to the data.

Oops, I have to run that first.

OK, there we go.

Now, if you do not have the signal processing toolbox, then it's totally fine.

You can use these three lines of code which do not rely on the signal processing toolbox or any toolbox

in particular, and that these three lines of code will replace the this line of code here.

Again, I don't have that.

I'm not going to take the time to talk about what this is doing.

Essentially, it's applying something called a zero phase shift filter, which makes sure that the filter

kernel is not imposing any phase delays in your signal.

OK, so now we have our filtered signal.

And remember, this started off just being as as pure broadband noise.

So let's see.

This is going to overwrite this figure here.

We see the broadband noise.

That's the original signal and the power spectrum.

So it's power spectrum.

Looks like white noise.

So you see that white noise looks like noise in the time domain and it basically looks the same in the

frequency domain.

So then we plot the times.

So now this is the filtered version of that signal.

So it's pretty neat.

It looks like what looks like a filtered version of the signal and let's see what the power spectrum

looks like.

So we're already missing something here.

So what do we want to do?

Well, we want the power spectrum of the filtered signal and I think I'll actually just copy and paste.

This code here now you will notice.

So this is called Filt Sig, you will notice that I'm not applying any of the normalization factors

that you need to get this this amplitude spectrum.

Or maybe I'll do I guess it was amplitude spectrum up here, wasn't it?

OK, so I'll keep this as the amplitude spectrum, not the power spectrum.

So I'm not applying these normalization factors because I really don't care about the actual values.

All I care about here is the overall shape of the distribution and the shape of the spectrum.

Oh, here it actually is called amplitude.

So I think this is supposed to say amplitude spectrum.

The shape of this distribution is the same, regardless of whether or not we can interpret these numbers

in terms of physical actual quantities.

OK, anyway, it's just a quick reminder.

So for an interesting comparison, we are going to plot these signals on top of each other in figure

twenty two.

So let's see here you see the original signal and red and its power spectrum and the filtered signal

and black and its power spectrum.

So it's interesting to to zoom in and just kind of have a look at this thing is on the one hand, you

really can't interpret this.

It's literally noise.

It is literally filtered noise.

But on the other hand, you can see when you look at the noise characteristics, you know this twenty

to twenty five hertz range, which we might call in the brain, you might call this the beta band.

Maybe you'd call this sort of middle beta band.

It has some interesting looking characteristics.

It's coming in bursts.

Here's a big burst and then we get a beta, a little bit of suppression and then a small burst and then

here's some rhythmic bursts.

Maybe this is like cross frequency coupling.

I'm doing apology quotes with my fingers here and here.

We get some larger bursts and so on.

So this is all pure noise.

It's just we are just finding patterns in noise.

Here you see the power spectrum and not surprisingly, the power spectrum is flat everywhere except

for this range from around twenty to twenty five hertz.

And that's not surprising, of course, because that's how we defined the filter, Colonel.

All right.

So that was about FBAR filters.

I'm now going to talk about the Hilbert transform.

Applying the Hilbert transform is really easy.

You just use the function.

Hilbert This function is in the signal processing toolbox.

However, I've also included this function in the downloads that you have for the resources from this

section of the course.

So if you don't have the signal processing tool box, then you have the Hilbert function from me.

All right.

So we take the Hilbert transform and now you can see that this is a complex valued signal, right?

The filtered signal is real valued and the Hilbert transform is complex valued.

There's a real part and an imaginary part at every time point.

So let's see now.

We want to make a new plot of the real part, the magnitude or the amplitude time series and the angle.

Now, I can already see that this is wrong.

In fact, if we would plot this, we're going to get, well, just the complex values here.

So what we want is this should be real.

This should be in magnitude is about the absolute value and the angle is angle.

So let's try this again.

So there you go.

And again, it's pretty interesting to see that you get these almost looks like rhythmic bursts of twenty

to twenty five hertz activity with a pretty respectable looking phase angle time series.

Now, of course, if you were doing this with real data for actual analyses, then you can pretty much

use exactly this code here.

And of course, you would just replace I hope you would replace this signal with your actual signal

instead of just being random noise.

And then this would be the magnitude, the amplitude time series.

You could square it and get the Power Times series.

And this would be equivalent to the results from complex Marlay Wavelet convolution from this frequency.

And then you would loop through a lot of other frequencies to build up a time frequency plot.

In the next video, I'm going to tell you about another method for time frequency analysis, and that

is the short time.

Forty eight transform.

I look forward to seeing you soon.