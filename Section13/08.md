 I'm now going to walk you through the code for the solutions to this project. You'll notice as I go through the code that there isn't really a whole lot of new information. There's not a whole lot of new code that I'm presenting here. It's mostly just copying and pasting from previous videos in this section and also videos in previous sections, in particular the section on connectivity analysis. All right. So loading the data make some time to inspect the data set, which we already did a little bit before. So. Sixty four channels, two seconds. So 2048 time points to the sampling rate of ten, twenty four. So that's two seconds and 63 contiguous segments. So let's see here. I filter the data and put it in a separate variable. So F data here I compute the covariance matrices and this is more or less the same, nearly exactly the same as what I showed in the video on frequency based generalized Agnelli composition for source separation in simulated data. The main difference is here. There's no it's not similarly data, of course. And I'm also just using all of the time points. So the are covariance matrix comes from the broadband data. The s covariance matrix comes from the filtered data. So let's see then. All of this is fine. So that's basically old code. And here this is also old code. This is code that you've seen before from the frequency based journalize. I can see competition video from this section. So that generates these plots. And then I see. Now I'm going to compute phase synchronization between the top two components. So I go from two hearts to 50 hertz in 100 steps using a full with that half maximum for the filter going from one hertz up to five hertz, linearly spaced from the filter for two words up to the filter for 50 hertz. And now, just to make the code a little bit easier, a little bit more compact, I'm using this function filter FDX. Of course, if you solve this using complex like wavelet analysis convolution or Narrabeen filtering in the Hilbert transform, that's totally fine. I'm doing it to this function, which is also a frequency domain, narrowband filter. Now you have to be really careful with all of the transposes here, in particular Trents you need. So you need to transpose the the data into the Hilbert transform and then you need to transpose it again. But here you actually want to take the apostrophe. So it's the normal transposed and not the commission transpose. This is the sort of thing that I discussed several times in previous videos in this course. All right. So ultimately, that's going to give me a matrix. It's the I'll run some of this. So what we get from here is a two by one hundred and thirty thousand, ten point matrix, so it's two component time series and then the one hundred and twenty nine, twenty two hundred and twenty nine thousand twenty four time points corresponds to two thousand forty eight time points time. Sixty three segments. So in here I compute the phase synchronization, I take it to the ISO oilrigs, the phase angle differences. I'm extracting the angles from the analytic signal here and then I take the diff which is the discrete derivative, and then you just need to make sure you're computing the difference over the first dimension, which is component, not over the second dimension, which is time. Of course, you could also do this as angle as one minus angle as to it's also fine. So then we take the average of these complex factors and the magnitude of the average vector, and then here I'm also extracting power and that's just extracting the power. So the amplitude square to get power and then average over the second dimension, which is time. Let's see. So that's pretty straightforward here. Imploding. Just, you know, this happens to be the last frequency, but that part doesn't really matter. It doesn't matter in the sense that you could also pick a different frequency, that would be totally fine. So that gives us this plot where you see some example, phase angle time series. And I like to plot these or I strongly recommend plotting these Phasing-in Time series whenever you're dealing with a Hilbert transform, because then you know that these are going to be the correct orientation. For example, if you don't do the correct flipping of the matrices, then you get so first of all, this the amplitude time series, which already looks wrong and the phase angles are also really wrong. That's even more obvious when zooming in like this. OK, so this looks really ugly, I can't stand looking at it, so I'm going to run it again with the proper flipping of the mattresses both inside and outside of the Hilbert transform. All right. So this is four figure five, all the face stuff and then four figure six, the power spectrum. Again, this is just example time series from 50 Hertz from it's just happens to be the last iteration in this loop. So the last frequency. And then here I'm computing the component power and again, as I mentioned in the previous video, this so summing up all the power time points over time is a close approximation to this static power spectrum from the FBI. And let's see. So in between the previous video in this video, I didn't even fix my embarrassing typo. It's awful. And this is also incorrect. This is power. All right. So now I'm going to extract the amplitude time series correlations so I get the top eight components. Again, this is not new code just in previous videos. In fact, even up here earlier in this script, I was getting just the first two components are here. I'm just getting the top eight components. And then here I have a bunch of code embedded into the same line, but essentially this takes the top eight components, let me show you what this looks like. So this is now eight by one hundred and twenty nine thousand filters these through the alpha filter. And actually, you know this you could have just done this. This probably would be easier to apply these to the filter data because I already created this data. And then here you wouldn't need this filter FDX thing. This could be just immediately top eight like this. So this is probably a better solution to use the filter data. But anyway, this is what I happen to do. So then put the Narrabeen filter data directly into the Hilbert transform and then extract the amplitude envelope here. Here I'm using the core Kohr function and in this case, you have to be careful to flip these again. So there's often a lot of transposing that gets done here. And this is going to give us a single matrix, a court matrix. And let me say I'll run these again. So this is the correlation matrix, you don't need to do this inside a double for loop, and you just have to be careful here that if you don't transpose this matrix, you're not going to get an error. Oh, actually, well, you do get an error. I think it's because of the size. Yeah, OK, so Matlab is basically trying to compute a time, point by time point correlation matrix, which first of all is not the right thing to do, is that we want we want the component correlation matrix. And also this ends up being such a ginormous thing. Maybe if you're working on a really powerful computer with a ton of memory, you can do this, but I can't on my little computer here. All right, anyway, then here I'm plotting an example. So this just shows a little bit of the time series data, the first segment of data, and then I make an image of the correlation matrix. So let's run all of that finally, so all these topographical maps and that part's not super interesting, it just goes through in a loop and we use this of plot and function. I multiply the ith eigenvector by the covariance matrix. And it's interesting to note that the covariance matrix is the same for all of these maps. So it's always the same covariance matrix. It's just the different eigenvectors. And that gives us these very different plots, which is actually not surprising. These are separate alpha sources. So done. That's the end. I hope you enjoyed working through this project. If you feel comfortable with solving this project starting from a blank script, then you should be very confident about analyzing your own data or anyone else's data using these kinds of multivariate and binary connectivity methods.