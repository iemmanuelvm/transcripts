 In this video, we are going to examine all to all phase synchronization, so all channels to all other channels in this V1 laminar data set. So you'll recall that this data set has 16 channels and by computing phase synchronization between each pair of channels, you can actually generate a full connectivity matrix, which is going to look something like this. So here you see a connectivity matrix. There's 16 channels by 16 channels. So the value here. So the color at this location in the Matrix corresponds to the synchronization between Channel 10 and Channel four. And now I don't actually have a color box. Let me put on a color bar here. So now you can see that this value so the synchronization between Channel 10 and Channel four is somewhere around 2.5, eight, let's say. Now, this matrix is symmetric and that makes sense. Phase synchronization is a non directional measure of coupling. So that means that the synchronization between Channel 10 and Channel four is exactly the same as the synchronization between Channel four and Channel 10. OK, so this map is for all to all synchronization at 40 hertz between zero, and that's actually a mistake. That should be point five seconds, not point five milliseconds. So this is the first five hundred milliseconds and then this is the same matrix for the second 500 milliseconds. So point five seconds to one second, also at 40 hertz. And then this is simply showing the difference between these two maps. And so the way to interpret this is that there is a group of channels here that exhibits stronger synchronization, stronger functional connectivity for the first five hundred milliseconds compared to the second five hundred milliseconds. Now, just by looking at this map, you see a few interesting features that are fairly prominent. One feature is that the synchronization is strongest on the diagonal. In fact, synchronization is one on exactly the diagonal. And that should be a sensible result because synchronization between Channel 14 and Channel 14 is, of course, perfect. And everything you see is that it's not only on the down, so it's ones on the diagonal, but it's also quite high around the diagonal and that reflects some volume conduction. So basically, neighboring electrodes share a common neural inputs. And then on top of that, you see some other interesting things, so it looks like there's a square that's somewhere around here. I think you can see this. It looks like there's a box here of stronger connectivity. And that's also interesting in light of the anatomy. And this is basically the channels that are in layer four, which as the primary input from the thalamus. In fact, I think you see that box shape even more prominently here in the first five hundred milliseconds. OK, so with that as an overview, I'm going to walk you through kind of briskly what this code does, I'm going to go through fairly briskly because there isn't really a whole lot of new material in this video, just different ways of putting together things that you've learned in the past, several videos, as well as the background section. So we are going to filter at 40 hertz. Using a width of 10 hertz, and I'll show you a little bit where this is used here, I define the two time windows and you have to keep in mind that with this data set the time it goes in seconds, not in milliseconds. So here I identify the time indices corresponding to these two time windows in seconds. Let's see here. I filter the data and extract the phase angles. So I'm filtering the data using this function filter FCX and you give a couple of inputs or four inputs, the data, the sampling rate, the center frequency and the width of the frequency as full with that half maximum. Now, if you provide an optional fifth input, then when you run this code, it will actually generate a new figure that shows you a little bit about the filter that gets applied to the data. So here's the frequency domain representation of the filter. So it's centered at 40 and you can see that it goes here from thirty five to forty five hertz. That's the full with that half maximum. And here you get an idea of the amount of temporal smoothing that is involved in applying this filter. So of course, if you are interested in the mechanics of this filter, you can open up this file and look through the function. Essentially, all it's doing is creating a Gaussian, applying that Gaussian to the data. And then, uh, yeah, well, returning this filter data and then the rest of this is basically just computing empirical parameters and making some visualizations. Then I apply the Hilbert transform and extract the angle, and I call that Angle Time series. So I was going to call this NG Test four time series, but then I thought it would be fun to call this thing angst, because maybe that's what you are experiencing as you were doing your connectivity analysis. OK, so I've mentioned in previous videos that it's really important when using the Hilbert function to make sure that the data are in the correct orientation. So what I'd like to show you now is how to check that and what it looks like when it's wrong. So this code was already run. So now what I'm going to do is plot some phase angles. So plot angst, let's see, let's do Channel five all the time points and trial 10. OK, so already these thing phase angles look a little bit weird. So I'm going to zoom in and have a look. Now, this is not really what you typically expect phase angles to look like. Typically phase angle time series look sawtooth and they should kind of go the other direction. You know, they should be going up and then down, not ergaster up more slowly and then straight down and then up a little more slowly. So this looks backwards and somehow this looks a little weird. It doesn't quite look right. And this so let me zoom in here. This definitely does not look right. So these are not correct. Phase angle time series. And what actually happened here is that the Hilbert transform was being applied to the FFE and the Hilbert transform was being applied across the channels instead of across the time points. Now, you can figure that out by looking at the Hilbert function and reading about it, but I think nothing beats visualization. So whenever you are extracting phase angles out of Hilbert, transform or in general applying Hilbert transform to a matrix input instead of a vector input. It's always a good idea to plot the Angles Time series and have a careful look at them. So if they look wrong like this and you're inputting a two dimensional matrix, then the first thing to try is transposing the Matrix. OK, so now I am transposing this matrix the input into the Hilbert transform and I'm going to try rerunning this cell. OK, so now let me get rid of this so we don't keep producing this figure. So now I got an error. It says subscripts assignment dimension mismatch. So something about dimension mismatch and that clearly is related to this transpose because that's the only thing that I changed. So what I want to do is look at some sizes. So let's see. The size of this is 15 by 16. Those numbers are sensible. This is time points and channels. However, if I look at the size of this, then that is 16 by 15. So, OK, no problem. So we transpose and now we need to transpose back. So now I'm going to transpose back like this. Now I run this cell again. No errors, no warnings. That's a good sign. But I still want to make some plots. All right. So already this is looking better. I don't see any of that really weird, funky looking face values that we saw the last time. However, these look backwards, right? So they go up sharply and then they go down slowly. And that's not how facing all time series are supposed to look. They're supposed to be flipped the other way around. Now, it turns out that the problem here is with this transpose operation in Matlab, a single apostrophe like this is actually computing something called the commission transpose, which means the transpose plus the complex conjugate and the complex conjugate is a way of flipping the imaginary component of a complex number. And that's what gives this thing. So to get the real transpose. You can use a dot apostrophe like this that I run this cell again. And now we have a look and finally we see phase angle time series exactly how we expect them. These are textbook phase angle time series. They go up and then we got up to PI and then it jumps down immediately to minus Pi and then it goes up slowly again. So at the risk of redundancy, I'm going to repeat this. The idea is that whenever you are applying the Hilbert transform to matrix inputs, so if you're applying to help transform just two vectors, you don't need to worry about this. If you're applying Hilbert transform to matrices, this is something you need to be concerned with. And if the phase angles don't look like this, this kind of sawtooth pattern where they're slanted up to the right and then they go sharply down, then you have to do something. And most likely you just need to do a little bit of transposing. Now, the other thing that I want to say about this is you could have avoided or I should say I could have avoided this madness by inputting a matrix that already has a time in the second dimension. That's essentially what I'm doing here. I'm putting time into the sorry first dimension. So I could have avoided dealing with this business if I had set up this loop differently. And for example, I had done things if I had done this channel was like this and I could say only copy bits and pieces here, then this would be all trials and dealing with one channel at a time. And of course, this would have to change as well because I'm looping now over channels, not over trials. I just want to show you that this construction would be accurate on its own without any transposition necessary. All right, good. So this now works. Let's see. Now I'm going to compute synchronization matrices. So I initialize this synchronization. Matt, it is two because we have two time windows and then the number of channels by the number of channels. So you can see I have a double for loop here. So I loop over channels and then I loop over channels again. Here I extract the angles for Channel I in the first time, window all trials and Channel J in the first time window and all trials. Here I compute the synchronization between them. So you recognize this as the phase angle differences, and then I embed them into Euler's formula, take the average and then take the magnitude of the average, that's the length of the average vector. And then I'm doing this over the second dimension, which is time. And that means that I'm going to get one synchronization value for each of two hundred trials. And then here I just average over all of those trials. Here is almost exactly the same code, except I'm using t idex, too, so the second time window instead of the first time window. So in this code, everything is written out as a double for loop. I think that's a nice way to see it in the beginning. It makes everything sensible. If you are up for a bit of a coding challenge, it turns out that you can solve this problem. You can generate these matrices using one for loop. So you just loop over channels once. And I think it should also be possible to do this without any for loops whatsoever using the best X1 function. So if you're up for a bit of a more advanced programming challenge, you can try to recreate these matrices without using any for loops. Nonetheless, there's nothing wrong with having a double for loop here. All right. And then here we do some plotting and I'm going to change this to say seconds instead of milliseconds. And let's see, I think that's it. OK, so now what I'm going to do is let's say I run this again. So now this was the results at 40 hertz. And remember, that showed stronger synchronization in the first time window and a little bit weaker synchronization in the second time window. You'll also notice that this actually changed these matrices look a little bit different. See, this is much more blue. You see these blue bars here. That's actually because we had that mistake. There was that error here in the Hilbert transform. When I first started the code, so the results were actually wrong, and that's not surprising now that you understand this error, the FFE that's inside the Hilbert function was being applied across the wrong dimension. We were taking the FFE over space, over channels instead of over time. So now we get the correct results. OK, now what I want to do is just play around a little bit, change this frequency a bit and show you how much these patterns of synchronization can change over different frequencies. So 40 hertz, let's try 50 hertz. So a little bit faster. And here, well, now you see something totally different. So very, very weak synchronization across the different channels except for around the diagonal in the early time window. But in the second time window, you see really strong synchronization. So the difference is quite strong. And this is prominent in the first couple of channels, which happens to be in the superficial air. So this is really the superficial layer of the cortex and V1 and this is around layer four here. Now we can try going up to, let's say, 60 hertz. See how that looks. So now we get a similar phenomenon, but I think there's even less synchronization here, in fact, if anything is maybe even going a little bit in the other direction. So relatively less synchronization or weaker synchronization and the second half of the stimulus compared to the first half, let's try it at, for example, 80 hertz. And now that effect goes away. And let's see, maybe we can try it at 30 hertz. Let's see what that looks like. So you can see there's a lot of things to play with. Of course, this is all very qualitative. I'm just kind of poking around randomly at some different frequencies and the gamma range and plotting them in later videos, in particular the video about all all synchronization. You'll learn some other ways to quantify this anyway. I hope you found this video interesting. And I will see you in the next video.