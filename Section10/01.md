 I'm going to kick off this section of the course on connectivity with synchronization in simulated noisy oscillators. This will be an interesting way for you to refresh your memory about the concept of phase synchronization and the mechanism of phase synchronization. And it will also give you a chance to have some code to play around with to see, for example, how robust synchronization is to various levels of noise. So what I'm going to do here is simulate two signals and you can see that those signals are the same. So two PI times this funny looking construction here. I say the average of the numbers in a range that is variable frequency range from 10 to 15 hertz, which basically means that these are going to be twelve point five hertz sine waves. And then I'm adding some unique noise. So basically these are going to be noisy oscillators. So they have a pure sinusoidal component and then there's some noise. So now let's see what kind of noise this is. So here's how I create the noise. I say 10 times. So this is clearly just an amplitude modulator of the noise. And then look what's happening here. I'm saying Fildes filled with some filter kernel that I'll explain in a minute and then just a bunch of random numbers for the same number of time points as is contained in the signal. So you can see that this is somehow a filtered version of random numbers. So this is basically filtered noise. OK, so now we understand these two lines. Now let's see. Oh, sorry. I also wanted to point out that these two lines are identical, which means that the filter that will be applied is the same. The only thing that's different is we get a different sampling of random numbers. So the noise characteristics for signal one and the noise characteristics for signal two are the same. They're just with different randomly generated numbers. All right. So this filter kernel comes from the output of this function, FIA one. And here you see what this F range variable is doing. So I'm going to create a filter kernel that will filter the data or narrowband filter the data between 10 and 15 hertz. And that is how we get the noise. All right. And here you see the simulation details that we simulate the data at a kilohertz for seven seconds. Now, notice, I would like to take a minute here, a little tangent to point out how I went about understanding and explaining this code rather than going line by line by line. I started at kind of the bottom, not technically the bottom, but this is just some plotting. And then I started from what looked to me like a pretty important set of code, piece of code, and then I worked my way up from there. Now, that might seem initially like it's backwards, but it's actually a good idea to inspect code, particularly code that you're not really familiar with in reverse order rather than in forward order. And that's because sometimes variables or lines of code don't really make sense when they're presented at the top. Unless you know what the goal is, you have to know where you're going in order to figure out why these are relevant. OK, anyway, let's move on here. I plot the signals so you can see these look like noisy oscillators. No surprise. They're clearly oscillating. They're clearly in roughly the same frequency range. But you can also see that there's a lot of dynamics in particular in the amplitude. So there's a lot of amplitude fluctuations over time. So the way that we are going to compute phase synchronization is by looking at the distribution of phase angle differences between these two signals. So I need to extract the phase angle time series from each of these signals. And there are multiple ways that you can do that. You already know how to do that through wave the convolution. And here I'm doing that through the Hilbert transform. So the Hilbert transform is going to return something called the analytic signal or a complex valued signal from the input. So this is a complex representation. It contains both real parts and imaginary parts. And from that complex analytic signal, I'm extracting the phase angle time series. So now I will plot those two for you and they look like this. Let me zoom in a bit here on this plot. It's always important to visualize the phase angle time series that you extract from the Hilbert transform. And the reason for that is that the Hilbert transform is assuming that your data are in a particular format. And if they're not, then you might actually be computing the Hilbert transform over a different dimension, over the wrong dimension. You will see specific examples of that in later videos, but this is what phase angle time series would look like. There is kind of rightward leaning sawtooth functions like this. And if you're facing a time series doesn't look like this, then there's something wrong. Something went wrong somehow and it could be with the Matrix orientation. Now, in this case, I'm not inputting matrices. I'm inputting vectors, so I don't have to worry about that. Still, it's always a good idea to plot the phasing of Time series. The other thing I would like to remind you of concerning the Hilbert transform is that it is applicable it's valid to apply, I should say. It's interpretable. The results of the Hilbert transform are interpretable only for narrowband signals. Now, I happen to know that this is a narrowband signal for two reasons. One, you can just look at the signals here and see that they are very concentrated in one frequency range. And two, just looking at how these are constructed. This is a pure sine wave plus noise. But this is not random broadband noise. This is narrowband noise filtered between 10 and 15 hertz. So if you don't already have a narrowband signal, then before you apply the Hilbert transform, it's a good idea to Narrabeen filter the signal to isolate the phases into one particular frequency range. OK, so to compute synchronization between these two signals, we are not interested. The phase angle time series themselves instead, what we are interested in is the difference in the phase angle time series, so literally at each time point the difference between the blue signal and the orange signal. And you want to know, are those differences consistent over time or do they diverge? Are they random over time? This is the formula to compute synchronization. So basically you take the angles from the two signals and you literally just subtract one phase angle time series from the other phase angle time series. So, yeah, as I said, that's the blue minus the orange or the orange, minus the blue. Actually there's a symmetric measure and then you take that phase angle difference time series and input that into Euler's formula. So you here you see E to the eye and then the phase angle differences. And when you're doing this, it's important to make sure you have parentheses around the phase angles, because a really easy mistake to make is to do something like this. And now here what you're actually doing is grouping the AI, the imaginary operator and the angles together. And this is separate. So this is actually wrong. Unfortunately, I will not give you an error. This is a valid line of code in terms of computing. But in terms of math, this is an incorrect line of code. OK, so this gives us a single number. This is a complex number and I'm going to illustrate to what this means. So what I'm doing here is using the polar function to make a plot of the distribution of phase angles for the two channels. So here on the left, you see the distribution of phase angles for signal one in blue and signal two in this dark gray color. Now, this is not so interesting. This is actually I mean, this looks really pretty. I like how this looks. The color scheme is nice, you know, the higher concentration to the center and it sends out so aesthetically it looks nice. But in terms of signal analysis, this is a pretty trivial result. That result is really just telling you that the phase angles are covering the entire circle. Now, this is actually not all the phase angles that I'm plotting here. I'm only plotting and to plot. So 200 time points. So out of 7000 total time points, I'm only plotting the first two hundred. So let's zoom in here and see what is going on in the first two hundred. So that's somewhere around here. And in fact, you can see this is really actually not representative of most of the signal because most of the signal it appears, you know, if you just zoom in anywhere, these are more or less kind of phase aligned. And here in the beginning, it happens to be that these are fais opposite of each other. And that's purely driven by the noise because the signal itself is an identical sine wave with identical phases. OK, but as I mentioned, we are not interested in the phase angles themselves, we are interested in the phase angle differences and that's what's being plotted here on the right. So here you see I'm plotting angles once this vector of the Phasing-in Time series from signalmen minus angles, too. So that's what's being plotted here. And then here you see the average vector. As I mentioned, it's a complex number. We can plot it here, treating this polar plot as if it were a complex plane. So here's the real part and the imaginary part. And what we're interested in here is the length of this average vector. Now, this is kind of a funny set of random numbers because it happens to be that the average points look completely in the opposite direction of all of these vectors. But you have to keep in mind that this is really just the first two time points. So if we were to change this into plot, to plot all the time points and not just the first two hundred, then it basically gets much harder to interpret just because there are 7000 of these lines. But it is actually the case that the clustering is pointing in this direction. So I'm going to undo this. And in fact, I think I will decrease this noise from a factor of 10 to a factor of one. So now the noise, instead of being 10 times higher than the signal, the noise is basically the same magnitude, the signal. So now I'm rerunning the entire script and now you see. So let's see. This is OK. Well, this is still the first 200 time points, but I believe here. Yet now you see there's very little noise. There's very little deviations in the signal. The phase angle time series are nearly identical between the two signals and therefore the distribution is really tightly mapped around zero. And I think actually, just out of curiosity, I'm going to uncommented this and recreate this figure so we can see what it looks like, what the clustering looks like. OK, so there's a couple of stray vectors that have wandered off the beaten path over here. But by and large, nearly all of the phase angle differences, not the phase angles themselves, those are uniformly distributed, but the phase angle differences are all pretty tightly clustered around zero. And this leads to a phase synchronization of point nine eight, which is really high. You can see the average vector almost goes to the edge of the plot here. So this is our quantification of the strength of synchronization between these two signals.