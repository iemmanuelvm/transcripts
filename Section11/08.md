 In the previous video, you learned about the theory of cluster correction and now you are going to get to put that theory into practice. So we are going to perform cluster correction on the data that we tested two videos ago. I think it was two videos ago. So this code requires having run the code from the previous video, as was the previous MATLAB video, to be more clear. So that was the video where we did permutation testing on the V1 data. And there we were looking to see if the power in Channel six was different from the power in Channel seven. So that was this video and I ended that discussion or I ended that video with a discussion about how we had so many tests. It was something like 4000, some on test, over 4000 individual tests. And we were using a uncorrected P value of zero point zero five. And now in this video, we are going to apply cluster correction to those data. All right. So let's see what we're going to do here. We're going to loop over iterations, any permutation test. Now, notice, we're looping over twice, like I mentioned in the previous video. So we have to loop over all the permutations once to generate these maps that we did two videos ago. And then you have to loop through all of these iterations again, because here you want to apply a threshold to this map. OK, so let's get started. We're going to initialize this vector here of maximum cluster sizes at each iteration, each permutation map, each of these 1000 empirical null hypothesis, time frequency maps. OK, so here I'm just extracting this image and we can even see what this looks like out of curiosity. So let's see that one and then run that one. And I'm just curious to see what this thing looks like. So Thresh AMG. So here's what that looks like and I'll turn axis x y. So again, this is time and this is frequency. These are indices. So you can't really interpret these things and you can actually see where the the two gamma bursts are appearing. OK, so what we want to do now is threshold this image to turn off any pixels that are below the significance value. So first of all, we want to do is transform to a Z map. So in fact, we've already written code for this for the real data, the real map. So we want to write Thresh AMG minus mean H not divided by SDD H not. And these were two variables that I created in the previous Matlab video. So then we get this Z map and then we want to threshold it. So we say any pixels in here that have a value Z value less than our significant threshold gets set to nine hundred and ninety nine. Really. Is that the right answer? That is probably not the right answer. I think we want to set those things to be zero. OK, so then now out of curiosity, I would like to see what this looks like. So I'm going to make an image of this again. And this looks like I don't know if it's raining blood and alien blood is here. OK, so there's a big intergalactic war between humans who have red blood and aliens have blue blood and they're fighting in the sky. And it's an awful, awful war. And there's just blue blood and red. OK, I'm done anyway. So this map contains zeros for the non significant pixels and these values for all of the well, we shouldn't really call these significant pixels, but super threshold pixels. OK, so what we want to do now is identify all of these clusters so we can then find the biggest cluster from this map. So we do that using or I'm doing that using this function. BW Con Kump. This is a function that is in the image processing toolbox. Now, unfortunately, if you don't have the image processing toolbox, there is not a really great simple solution for identifying clusters. So if you don't have the image processing tool box, you don't have access to it at your university or work or whatever, then at least you can watch and follow along. But don't worry, when we get to the next video on pixel based, extreme pixel based correction, that one doesn't rely on the image processing toolbox. OK, so I want to show you what this result is. So we have this output from Betawi. We can it's a variable called islands and it is a structure with the following field. So connectivity, image size, this should look familiar. That's the size of the image. And this is the number of objects, these are the objects that are the clusters that BW has identified in this image, and then we have this thing called Pixel IDEX list, and it's a cell array with 39 individual cells. So let's see what this looks like. So I'm going to say islands, that pixel IdeaCast list. So this is a list of pixel indices where there are a individual clusters. So let me show this again, the image and see this. Yeah, so the idea is that each of these is a cluster and B.W. is going to return one cell for each of these individual clusters. And so we can see that the first cluster contains 20 pixels. And that first cluster, I guess, is probably this one. And then we have the next cluster, which contains five pixels, and that's this one. The next cluster has three pixels. That's this one. And it's going to go on, you know, like this down the columns and across the rows. So these correspond to the indices of these all the pixels inside this cluster and so on. So that makes our job of counting the number of pixels in each cluster pretty easy because what we have to do is or what the way that I'm implementing this is to say use this function cell phone, which is a cell function. So I want to apply this function length to each element in this cell array. So this is going to return a vector of numbers and we can actually look up. So this was 25 three. That's what we saw here with this cell array. So this tells us the list of all of the pixel indices in each cluster, and this tells us the number of pixels in each cluster, which is exactly the information that we want. OK, now the thing is, you know, it can happen that there are literally zero significant pixels or super threshold pixels inside this map, which is in fact the expected result. So if that happens, then this is going to this line will crash. So that's why I have this statement here. So if the number of cells in this array is not is equal to zero, then basically this doesn't get run. OK, so here I find the all of the clusters sizes and then here I just take the largest one. So let's run through all of these iterations and we can make a plot of this max cluster size. So plot max cluster size and that looks like this. So here you see most of the clusters are somewhere around. What do you think the average might be 50 or so, and then there's a pretty long tail. So there's a couple of iterations where we happen to get one hundred and forty in one cluster. We can actually look at this map. This is X value 140, which means that it's map 140. So we can make an image of the perm map's 140 by frequency's by time. So I guess it probably comes from this big cluster here. OK, now there's no real particular reason why I'm visualizing all this stuff. Partly I'm curious to see what these things look like. And partly I want to instill a kind of mindset in you that it's always good, particularly when you're going through new code, new analysis code. It's always good to plot and be curious and inquisitive and plot more where every possible step whenever you can. And in fact, if I would make as many plots here in these videos as I would personally as I'm going through this stuff, then this course would be like eight times as long. OK, but I have to limit myself to some number of plots and then, you know, time starts running out. And anyway, let's look at a histogram of these plots of these cluster sizes, maximum cluster sizes. So this is just a histogram of the plots that we were just looking at a moment ago. So you can see this is an example of where we have a very strong non Gaussian distribution in simulated in per mutated data. OK, so what we want to do now is find the cluster threshold that corresponds to a P value of zero point zero five. Now, a couple of videos ago, I discussed whether the P value of zero point zero five was actually being implemented correctly, given that we were taking the absolute value of the Z maps. In this case, we are only looking for a one tailed test. We are not doing a to tell test. We have no predictions, no expectations or even ways to interpret these small clusters. All we want are the large clusters. So we get the 90th percentile of this distribution and that corresponds to one hundred and sixty seven, which is somewhere around here. OK, so then what do we do? We go back to this original Z map. Now, this is the Z map that I created in the previous Matlab video. This is the true Z map for the actual data relative to the empirical null hypothesis distribution. And now what? We are going to go. Through where we are now going to do is loop through all of the objects in this Z map, so still using this function, B.W. can come. But now this is for the real data. So there are twenty four clusters in here. Twenty four contiguously significant regions. And what we are going to do is loop through each one of them and we say if the eye can even just close these figures here, we count the total number of pixels in that cluster in the cluster. If that is smaller than our null hypothesis threshold that we determined empirically using permutation testing, then we set in the Z map, we set all of those pixels to be equal to zero. OK, so run that code and let's have a look at these plots. All right, so that is pretty interesting, we see here is the time, frequency, power with no threshold, the time, frequency, power difference between electrodes six and seven with no thresholding. And here it is with Kluster, correction. So remember, there was all these little flighty things all over the place. There were twenty four clusters. Now there's only one only one cluster survived. Here you see the map threshold. What you're looking at here in this subplot is the same power plant here, but with a contour line drawn around the significant region. So that's pretty interesting. These clusters were not significant enough. They weren't big enough to survive the cluster thresholding. And I think that's the end of the code here. Yep. OK, so this is one method for computing or dealing with multiple comparisons, corrections. In the next video, I'm going to teach you about another method that we can also incorporate into this permutation testing framework, and that is extreme pixel based correction.