Noise is a major topic in many areas of science, in particular in signal processing and engineering,

there are many types of noise, there are many flavors of noise.

There are many ways to create noise.

What I'm going to do in this video is introduce you to a few relatively straightforward ways of creating

different kinds of noise.

So first is white noise, and we're going to simulate white noise in two different ways using a normal

distribution.

This creates noise that has a probability distribution that is Gaussian and uniform noise where the

probability distribution looks like this.

So it's just a sharp plateau.

Now, these are not the noise values themselves.

The idea is that these are the probability values.

So when you generate a new sample of noise, you are more likely to get a random number from this part

of the distribution.

So of corresponding to values close to zero, and you're less likely to get larger values or I should

say values further away from zero.

So that means for the uniform distribution, the randomly generated numbers are equally likely to appear

anywhere between zero and one, and they never occur below zero and they never occur above one.

So these are kind of the basic two distributions.

It's also possible to modify or modulate these distributions using two parameters, a shift parameter

and a stretch parameter.

So shifting parameter means to take this entire distribution and move it to the left or move it to the

right.

So, for example, if you want wanted normally distributed numbers that have a standard deviation of

one but mean value of, let's say, six, then you would slide this whole distribution over six points

or six units and that would be the shift parameter.

And the stretching parameter allows you to change the width of these distributions.

For example, imagine you wanted uniformly distributed numbers between Zero and PI.

Then all you would have to do is multiply this distribution.

So generate a uniform distribution between zero and one and then multiply those values by PI.

And now you've stretched this distribution.

OK, so this is two different ways of generating what's called white noise.

Next, I want to show you pink noise.

And the key difference with pink noise is that it has a power spectrum that decreases with increasing

frequency.

So this is the amplitude spectrum of pink noise and you can see that the amplitude is higher for lower

frequencies and it gets smaller as the frequencies increase.

Now, it's interesting that pink noise also has kind of a Gaussian looking distribution.

It's not a perfect Gaussian, but this is just some random sample.

So what really affects the characteristic of pink noise?

What really distinguishes pink noise from white noise is the temporal structure of the signal.

And it's also interesting to look at pink noise in the time to name it somehow looks more biological

than white noise.

And you'll see this also in the Matlab code.

OK, so there are several ways to construct pink noise.

You'll learn a few different ways throughout this course.

The main way that I'm going or the only way that I'm going to show you in this video is by generating

random numbers that come from a distribution, a frequency distribution that you specify.

So this general shape, it's often called one over F more formerly it's one over F to the C, or you

could also say F to the minus C and C, this parameter here defines this decay shape here.

So C is larger than the decay is steeper.

If C is smaller than the decay is more gradual.

So what we are going to do to generate pink noise is start in the frequency domain, generate an amplitude

distribution that is random numbers that are shaped by this one over F function and then use the inverse

Fourier transform to get from the frequency domain into the time domain.

OK, now we'll switch to Matlab and let's see how to implement these different characteristics of noise.

So first, we have normally distributed noise and you can see these are simulation details, we're going

to simulate data with a sampling rate of 100 hertz and we're going to generate a time series of noise.

It's going to go from minus one second to two seconds.

And here we have a variable that is missing something here.

This points.

So my guess is that we are supposed to specify the total number of points, which is the length of this

time vector.

Here I specify a vector of frequencies and Hertz.

Here are the two noise parameters that I discussed in slide.

So we have the stretching parameter and the shifting parameter.

I'm going to talk about this in a minute.

And let's see, I think actually the rest of this code is fine.

I think we don't need to do much here.

So here we generate the noise.

You can see the key.

Variable here is or the key bit of code here is this here, so we generate normally distributed random

numbers that is the same size as the vector of time points.

And then we multiply that by a stretch parameter and add to it the shift parameter, which in this case

is.

That doesn't do anything, but we're going to change this in a little bit, OK?

And then we've got the results.

Make a histogram of the noise and look at the amplitude spectrum using the FFE function.

So let's see what this looks like here.

You can see the normally distributed noise.

So it just looks like random numbers here in the time domain here in the frequency domain.

It's interesting that the power spectrum actually looks a whole lot like the time domain signal, doesn't

it?

So that's one feature of white noise that both the time series in the time domain and in the frequency

domain, they're both basically flat.

Now, of course, this isn't a perfectly flat line.

That's because of sampling variability.

But if you would increase the number of points here, you know, as you get closer to an infinity of

points, then this approach is a flat line.

So the power spectrum here is flat.

Here you can see the distribution.

Now, this doesn't look like a perfect Gaussian that I showed in the slide, but that's no surprise.

We are only generating how many points do we have here?

We are only generating 300 points.

Now, I'm going to run this code over again multiple times.

And you can see, you know, you can kind of imagine smoothing and averaging in your mind.

And this is going to approach a Gaussian.

This is going to approach a flat line.

So let's check out the values here.

It's zero.

It's roughly centered at zero.

And it looks like the distribution goes kind of like from minus five to plus five.

And I'm going to do now is change the stretching parameters, these two nice parameters.

So let's set this to be point three and let's set that one the shift parameter to be three.

So now a few things have changed.

One, this is now centered at three instead of at zero.

This distribution is now sent.

This histogram of the values is now to three.

It's also much narrower.

Remember, just before around the code, it went from minus five to plus five.

Now it's going.

So that was the total width of around 10 units.

And here it's a total width of around one unit.

Now the frequency domain looks quite different.

You don't really see much here.

What's actually happening is there's a big DC offset.

And that you see here, so there's a big DC offset of three and then the rest of the numbers are all

down here.

So this part of the spectrum is going to look pretty similar to the previous plot.

Let me get rid of that.

Now, what I want to do is uncommented this code here.

So this is the function orangy three.

Now, there's nothing special about three.

That's basically just to see what I'm doing is forcing the random number generator in Matlab to have

a state of three.

So now the results change.

They look different.

But if I run it again, the results are exactly the same.

And maybe you think that just something broken the code.

So burn this image into your retina here.

I'm going to close the figure.

Run it again.

And it's still exactly the same.

So basically the random number generator seed has been fixed.

So we always get the same results and now we're getting different results because I've uncommented this

line.

This sort of thing is useful to know if you are analyzing data and you're looking at the effects of

noise, if you want to make sure that your results will be exactly reproducible, every single time

you rerun the analysis, you might want to fix the random number generator seed.

And this is how you do that.

All right.

So this is for normally distributed numbers.

You will see uniformly distributed random noise in a later video.

It works basically the same way.

You just use the random function instead of random.

And so you'll see that in the near future.

Now, what I want to do is generate pink noise, also called one of retinoids, also sometimes called

fractal noise.

So I'm not going to go into too much detail about the mechanics, although if you are familiar with

the Fourier transform, you should be able to interpret some of these mechanisms.

This is the exponential decay parameter.

This is the key parameter that defines how steeply the slope.

I should say the amplitude function goes down towards zero, and that's basically going into this exponential

function here.

So what I'm doing is generating uniformly distributed random numbers, multiplying them by a negative

exponential.

You can think of this as like the side of a Gaussian that goes down to zero.

And then here I mean, these are these are treated as Fourier coefficients.

Mirror them, add some random faces, and then take the inverse Fourier transform.

So let's see what this does.

Here you see the pink noise in the time domain.

In the frequency domain, you see the one of rough shape.

And here's the distribution.

And again, I mentioned this in the slides, but it's worth reiterating that the difference between

pink noise and white noise is not really in the distribution.

You can see that the histograms look pretty similar.

Obviously, they're not identical, but this one looks a little bit calcium.

So that is the distribution of data.

Values alone is not what distinguishes pink noise from white noise.

Instead, what distinguishes pink noise from white noise is the temporal structure, the correlational

structure over time.

And I think you can see if you've worked with biological time series data, I think you will agree that

this somehow looks more realistic, this looks more biological.

This really just looks like noise.

And that's really all because of this shape here.

OK, so what I encourage you to do here is spend some time playing around with this code, also the

above code and the key parameter to change, of course, you can try changing any of these parameters

that you like.

The key parameter to change is this exponential decay.

You can see what happens when you make it really small.

So that changes the time series data quite a bit.

You can see what happens when you make this really large, let's say 5000.

And now it actually really looks a whole lot like white noise.

In fact, the decay is so gentle, it's so gradual that it's barely going down.

Maybe 5000 is a little much.

Let's say 500.

OK, this looks a little bit better.

This is at least still plausibly one over F over the next few videos, you will see how to use these

kinds of noise simulations to generate EEG data that we will use for testing analysis methods.